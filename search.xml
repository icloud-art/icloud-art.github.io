<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Charles工具进阶篇]]></title>
    <url>%2F2020%2F01%2F31%2FCharles%E5%B7%A5%E5%85%B7%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[我们都知道Charles是一款好用的抓包工具，其实它的功能是非常强大的，下面我们就一起看一下Charles这个工具的一些其他常用功能。 使用Charles进行网络环境模拟在开发中，我们要经常考虑各种边界问题，对于网络开发，告诉网络、弱网络、上行和下行带宽差异等都是我们要进行适配的场景，Charles就可以很好的模拟这些环境。接下来我们就一下看一下如何模拟： 在Charles菜单栏的Proxy菜单中选择 Throttle(节流阀) Settings 菜单项，这个可以用来进行网络字节流的设置，就是我们说的网络环境模拟，如图(1)： 图1 在弹出的新窗口中，我们就可以进行网络设置了，如图(2)： 图2 勾选Enable Throttling选项则表示开启网络节流功能，可以看到，在图(2)的窗口中还有一个Only for selected hosts 选项，开启这个选项后，我们可以配置一些主机地址，从而只会针对这些主机地址的请求进行节流控制。 在Throttle preset 中预设了多种网络环境，对每一种预设都配置了一套网络环境参数，我们也可以自定义。 下面来解释一下窗口中的各个参数：Bandwidth 用来配置上行和下行网络的带宽 Utilisation 用来设置上行和下行网络的利用率。 Round-trip latency 用来设置往返的延迟时间。 MTU设置网络最大传输单元 Reliablity 设置网络可靠率。 Stability 设置网络稳定性。 Unstable quality range 设置不稳定范围。 当我们根据自己的需求自定义了一套网络环境参数后，也可以进行保存，填写完成后点击Add Preset按钮即可新增一种自定义预设，Remove Preset用来删除预设。实际上这个预设是一个XML文件，我们可以将其导出给其他人使用。Charles提供了非常人性化的导入/导出功能。 使用Charles添加请求断点]]></content>
      <categories>
        <category>技术人生</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多版本Cocoapods切换]]></title>
    <url>%2F2020%2F01%2F31%2F%E5%A4%9A%E7%89%88%E6%9C%ACCocoapods%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[背景很多 iOS 项目都是基于特定版本的 CocoaPods，使用其他版本的 CocoaPods 执行 pod install 或 pod update可能出现项目无法编译的问题。由于我们的电脑上很有可能使用了其他的版本，本文主要介绍如何解决这种多版本 CocoaPods 切换的问题。 查看本地装的pod可以通过1gem list --local | grep cocoapods 命令来查看我们电脑上安装了哪些版本的pod,并可以通过1pod --version 来查看当前默认版本。 使用BundlerBundler 是一个 Ruby 项目的管理工具，可以理解成为 Ruby 界的 “CocoaPods”。准确来说，CocoaPods 是借鉴了 Bundler 的思想和模式。由于 CocoaPods 本身也是一个 Ruby 项目，因此我们可以通过 Bundler 来管理我们要使用的 CocoaPods 版本，完整的步骤如下所示: 安装Bundler,打开终端输入以下命令： 1gem install bundler 在终端中进入到项目所在的根目录就是podfile所在的目录。 创建Bundler的配置文件Gemfile,在终端中输入下面的命令即可。 1bundle init 在Gemfile中设置cocoapods的版本。例如： 12source &quot;https://rubygems.org&quot;gem &quot;cocoapods&quot;, &quot;1.5.3&quot; 安装特定版本的pod,如果已经安装则可忽略这一步。执行如下命令： 1bundle install 此时，Gemfile中配置的pod版本就安装到本地了。 使用Bundler控制上一步安装的pod来安装我们所需的pods。除了有bundle exec 这个前缀，其他和我们平时用pod命令一样。若去掉bundle exec 这个前缀，运行的就是默认版本的cocoapods了。1bundle exec pod install 另外，还可以通过其他方式运行指定版本的pod，如：1pod _1.5.3_ install 亲测有效。]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的FPS监控器]]></title>
    <url>%2F2020%2F01%2F27%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84FPS%E7%9B%91%E6%8E%A7%E5%99%A8%2F</url>
    <content type="text"><![CDATA[最近在看有关iOS性能监控方面的知识，了解到如何通过CADisplayLink来实现一个简单的屏幕刷新帧率监控的方法，在Blog里面做一个Mark。 首先我们要了解一下CADisplayLink是个什么玩意儿，官方给出的解释是这样的： 1A timer object that allows your application to synchronize its drawing to the refresh rate of the display. 说白了，就是以屏幕刷新频率将内容绘制到屏幕上的定时器。它可以以屏幕的刷新频率调用指定的selector,而iOS系统中正常的屏幕刷新频率为60Hz(每秒60次)，那我们只要在这个方法里面统计每秒这个方法执行的次数，通过调用次数除以时间间隔(_count/interval)就可以得出当前屏幕的刷新频率了。 接下来贴出核心代码： 12345678910111213141516171819202122232425262728293031323334353637383940// 开始监控FPS的方法- (void)start &#123; if (_displayLink) &#123; _displayLink.paused = NO; &#125;else &#123; _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(triggerFps:)]; // 让当前runloop在 UITrackingRunloopMode 下可以接收到回调 [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; &#125;&#125;// 刷新频率回调方法- (void)triggerFps:(CADisplayLink *)displayLink &#123; // 大约每1/60秒调用一次 就是说每16.7ms 要产生一帧画面。 // 记录第一次调用时的时间戳 if (_lastTimestamp == 0) &#123; _lastTimestamp = displayLink.timestamp; return; &#125; _count++; // 当count=60 时 interval &gt;= 1 才会执行后面的fps值计算 NSTimeInterval interval = displayLink.timestamp - _lastTimestamp; if (interval &lt; 1) &#123; return; &#125; // 计算出fps CGFloat fps = _count / interval; // 记录上一次的时间戳 _lastTimestamp = displayLink.timestamp; // reset _count _count = 0; // 调整fps值 NSInteger intFps = (NSInteger)(fps + 0.5); self.currentFps = intFps; if (self.FPSBlock) &#123; self.FPSBlock(self.currentFps); &#125;&#125; 通过上面的代码就能统计到帧数的变化了，这个FPS指示器也就完成了。]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage (5.0.6) 图片缓存读写原理]]></title>
    <url>%2F2019%2F08%2F04%2FSDWebImage%20(5.0.6)%20%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[SDWebImage (5.0.6)图片加载奇淫巧技 这篇文章介绍了SDWebImage加载图片的流程是怎样的，本文我们一起讨论一下，SDWebImage框架的缓存机制是怎么样的。我们先来看加载过程中，SDWebImage是如何从缓存中读取我们所需的图片的，我们先找到读取缓存的入口：12// Start the entry to load image from cache [self callCacheProcessForOperation:operation url:url options:options context:context progress:progressBlock completed:completedBlock]; 这个方法就是开始从缓存中读取，方法内部实现如下：123456789101112131415161718192021222324252627// Query cache process- (void)callCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operationurl:(nonnull NSURL *)urloptions:(SDWebImageOptions)optionscontext:(nullable SDWebImageContext *)contextprogress:(nullable SDImageLoaderProgressBlock)progressBlockcompleted:(nullable SDInternalCompletionBlock)completedBlock &#123; // Check whether we should query cache BOOL shouldQueryCache = (options &amp; SDWebImageFromLoaderOnly) == 0; if (shouldQueryCache) &#123; id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter]; NSString *key = [self cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter]; @weakify(operation); operation.cacheOperation = [self.imageCache queryImageForKey:key options:options context:context completion:^(UIImage * _Nullable cachedImage, NSData * _Nullable cachedData, SDImageCacheType cacheType) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; [self safelyRemoveOperationFromRunning:operation]; return; &#125; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock]; &#125;]; &#125; else &#123; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:nil cachedData:nil cacheType:SDImageCacheTypeNone progress:progressBlock completed:completedBlock]; &#125;&#125; 从上面的源码可以看出，首先会判断一下是否需要从缓存中读取，如果不需要就直接去下载了。如果需要的话，就会使用self.imageCache实例去查询缓存，核心代码：123456789[self.imageCache queryImageForKey:key options:options context:context completion:^(UIImage * _Nullable cachedImage, NSData * _Nullable cachedData, SDImageCacheType cacheType) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; [self safelyRemoveOperationFromRunning:operation]; return; &#125; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock];&#125;]; 我们可以看到，查询结果回调之后，又调用了下载方法，这时因为缓存查询的结果也在下载方法里面处理了。我们接着看查询缓存的方法：queryImageForKey: 看下它的内部实现:1234567891011- (id&lt;SDWebImageOperation&gt;)queryImageForKey:(NSString *)key options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context completion:(nullable SDImageCacheQueryCompletionBlock)completionBlock &#123; SDImageCacheOptions cacheOptions = 0; if (options &amp; SDWebImageQueryMemoryData) cacheOptions |= SDImageCacheQueryMemoryData; if (options &amp; SDWebImageQueryMemoryDataSync) cacheOptions |= SDImageCacheQueryMemoryDataSync; if (options &amp; SDWebImageQueryDiskDataSync) cacheOptions |= SDImageCacheQueryDiskDataSync; if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages; if (options &amp; SDWebImageAvoidDecodeImage) cacheOptions |= SDImageCacheAvoidDecodeImage; if (options &amp; SDWebImageDecodeFirstFrameOnly) cacheOptions |= SDImageCacheDecodeFirstFrameOnly; if (options &amp; SDWebImagePreloadAllFrames) cacheOptions |= SDImageCachePreloadAllFrames; return [self queryCacheOperationForKey:key options:cacheOptions context:context done:completionBlock];&#125; 这个方法里面做了一堆跟缓存相关的条件判断，然后调用了queryCacheOperationForKey:这个方法，正式进入缓存查询。我们接着看这个方法的源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options context:(nullable SDWebImageContext *)context done:(nullable SDImageCacheQueryCompletionBlock)doneBlock &#123; if (!key) &#123; if (doneBlock) &#123; doneBlock(nil, nil, SDImageCacheTypeNone); &#125; return nil; &#125; id&lt;SDImageTransformer&gt; transformer = context[SDWebImageContextImageTransformer]; if (transformer) &#123; // grab the transformed disk image if transformer provided NSString *transformerKey = [transformer transformerKey]; key = SDTransformedKeyForKey(key, transformerKey); &#125; // First check the in-memory cache... UIImage *image = [self imageFromMemoryCacheForKey:key]; if ((options &amp; SDImageCacheDecodeFirstFrameOnly) &amp;&amp; image.sd_isAnimated) &#123; #if SD_MAC image = [[NSImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:kCGImagePropertyOrientationUp]; #else image = [[UIImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:image.imageOrientation]; #endif &#125; BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryMemoryData)); if (shouldQueryMemoryOnly) &#123; if (doneBlock) &#123; doneBlock(image, nil, SDImageCacheTypeMemory); &#125; return nil; &#125; // Second check the disk cache... NSOperation *operation = [NSOperation new]; // Check whether we need to synchronously query disk // 1. in-memory cache hit &amp; memoryDataSync // 2. in-memory cache miss &amp; diskDataSync BOOL shouldQueryDiskSync = ((image &amp;&amp; options &amp; SDImageCacheQueryMemoryDataSync) || (!image &amp;&amp; options &amp; SDImageCacheQueryDiskDataSync)); void(^queryDiskBlock)(void) = ^&#123; if (operation.isCancelled) &#123; // do not call the completion if cancelled return; &#125; @autoreleasepool &#123; NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage; SDImageCacheType cacheType = SDImageCacheTypeNone; if (image) &#123; // the image is from in-memory cache, but need image data diskImage = image; cacheType = SDImageCacheTypeMemory; &#125; else if (diskData) &#123; cacheType = SDImageCacheTypeDisk; // decode image data only if in-memory cache missed diskImage = [self diskImageForKey:key data:diskData options:options context:context]; if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = diskImage.sd_memoryCost; [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; &#125; if (doneBlock) &#123; if (shouldQueryDiskSync) &#123; doneBlock(diskImage, diskData, cacheType); &#125; else &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, cacheType); &#125;); &#125; &#125; &#125; &#125;; // Query in ioQueue to keep IO-safe if (shouldQueryDiskSync) &#123; dispatch_sync(self.ioQueue, queryDiskBlock); &#125; else &#123; dispatch_async(self.ioQueue, queryDiskBlock); &#125; return operation;&#125; 接下来我们解析一下这个方法：首先做了参数合法性判断，不满足条件直接返回空。紧接着就是从内存缓存中查询我们需要的图片：12// First check the in-memory cache...UIImage *image = [self imageFromMemoryCacheForKey:key]; 这个方法比较简单，就是直接从memCache中按照key来读取： [self.memCache objectForKey:key];接下来判断图片是否是动图，做相应的处理。然后，判断是否是只需在内存中查找，如果是的话直接返回刚才查到的图片，并结束方法调用。如果不是的话，就去硬盘中查找。1NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; 我们先把这个流程看完再来看究竟是如何从磁盘中读取Data的。接下来通过一系列条件得出是否需要同步查询缓存：12BOOL shouldQueryDiskSync = ((image &amp;&amp; options &amp; SDImageCacheQueryMemoryDataSync) ||(!image &amp;&amp; options &amp; SDImageCacheQueryDiskDataSync)); 然后生命一个磁盘查询的block: queryDiskBlock开始查询。接下来判断是否从内存中读取到了图片，如果有的话，不做其他处理，最后回调的时候把diskData一起回调出去就可以了。如果没有从内存中读取到图片，则就要看diskData是否为空，如果不为空，就对diskData进行解码处理，得到我们需要的diskImage。12// decode image data only if in-memory cache misseddiskImage = [self diskImageForKey:key data:diskData options:options context:context]; 然后把得到的diskImage放到内存缓存中一份。1234if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = diskImage.sd_memoryCost; [self.memCache setObject:diskImage forKey:key cost:cost];&#125; 到这里，从内存以及磁盘中读取缓存的流程完毕，接下来就是把我们读取出来的图片数据返回给调用方了。123456789if (doneBlock) &#123; if (shouldQueryDiskSync) &#123; doneBlock(diskImage, diskData, cacheType); &#125; else &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, cacheType); &#125;); &#125;&#125; 最后就是根据是否需要同步查询来调用queryDiskBlock了。这就是图片缓存查询的流程。接下来，我们回头看一下磁盘缓存查询究竟是如何实现的。1NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; 我们看一下这个方法的内部实现：1234567891011121314151617181920- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123; if (!key) &#123; return nil; &#125; NSData *data = [self.diskCache dataForKey:key]; if (data) &#123; return data; &#125; // Addtional cache path for custom pre-load cache if (self.additionalCachePathBlock) &#123; NSString *filePath = self.additionalCachePathBlock(key); if (filePath) &#123; data = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil]; &#125; &#125; return data;&#125; 首先是key参数判断，其次从diskCache中通过key来读取，如果磁盘缓存，内存中已经读取过的话，直接返回。否则的话，就会通过key得出磁盘缓存的路径，然后读取出来，返回给调用方。 接下来，我们一起看一下，从Server端下载完图片后，SDWebImage是如何处理的他两级（内存缓存、磁盘缓存）缓存的。同样的我们先找到保存缓存的入口方法：1[self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock]; 这个方法的调用时机，是在从网络下载完图片的回调中。这个方法的内部实现中有一句很重要的代码，就是我们存储缓存的代码：1[self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key cacheType:storeCacheType completion:nil]; 接下来我们来看一下，这个方法的内部实现：1234567891011121314151617181920212223242526- (void)storeImage:(UIImage *)image imageData:(NSData *)imageData forKey:(nullable NSString *)key cacheType:(SDImageCacheType)cacheType completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;switch (cacheType) &#123; case SDImageCacheTypeNone: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:NO toDisk:NO completion:completionBlock]; &#125; break; case SDImageCacheTypeMemory: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:YES toDisk:NO completion:completionBlock]; &#125; break; case SDImageCacheTypeDisk: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:NO toDisk:YES completion:completionBlock]; &#125; break; case SDImageCacheTypeAll: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:YES toDisk:YES completion:completionBlock]; &#125; break; default: &#123; if (completionBlock) &#123; completionBlock(); &#125; &#125; break; &#125;&#125; 内部实现其实比较简单，就是根据缓存类型做相应的存储。这一句才是重点：1[self storeImage:image imageData:imageData forKey:key toMemory:YES toDisk:YES completion:completionBlock]; 我们接着往下面看：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (void)storeImage:(nullable UIImage *)imageimageData:(nullable NSData *)imageDataforKey:(nullable NSString *)keytoMemory:(BOOL)toMemorytoDisk:(BOOL)toDiskcompletion:(nullable SDWebImageNoParamsBlock)completionBlock &#123; if (!image || !key) &#123; if (completionBlock) &#123; completionBlock(); &#125; return; &#125; // if memory cache is enabled if (toMemory &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = image.sd_memoryCost; [self.memCache setObject:image forKey:key cost:cost]; &#125; if (toDisk) &#123; dispatch_async(self.ioQueue, ^&#123; @autoreleasepool &#123; NSData *data = imageData; if (!data &amp;&amp; image) &#123; // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format SDImageFormat format; if ([SDImageCoderHelper CGImageContainsAlpha:image.CGImage]) &#123; format = SDImageFormatPNG; &#125; else &#123; format = SDImageFormatJPEG; &#125; data = [[SDImageCodersManager sharedManager] encodedDataWithImage:image format:format options:nil]; &#125; [self _storeImageDataToDisk:data forKey:key]; &#125; if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; &#125;); &#125; else &#123; if (completionBlock) &#123; completionBlock(); &#125; &#125;&#125; 接着我们分心一下存储缓存的最关键的方法，没错，就是上面的这段代码。首先，对参数进行合法性判断，如果不合法，直接返回。否则继续向下执行:第一步：判断是否允许内存缓存，如果允许就把下载好的图片存储在内存中一份。第二步：判断是否允许存储到磁盘，如果允许就进入磁盘存储逻辑：这里的存储任务是提交到了一个异步的串行队列中。任务的具体处理逻辑是：如果imageData 不存在，但是image 有值，则对image进行归档，得到一份data,这也是我们要写入到磁盘的data。最后，调用_storeImageDataToDisk:方法，将二进制图片数据写入到磁盘。第三步：将结果回调出去。 我们看一下_storeImageDataToDisk:方法的内部实现：12345678// Make sure to call form io queue by caller- (void)_storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123; if (!imageData || !key) &#123; return; &#125; [self.diskCache setData:imageData forKey:key];&#125; 比较简单，就是通过diskCache 实例来写缓存。接着我们进入diskCache类里面看下是如何写入的。我们看下SDDiskCache里面的setData: forKey:方法实现：1234567891011121314151617181920- (void)setData:(NSData *)data forKey:(NSString *)key &#123; NSParameterAssert(data); NSParameterAssert(key); if (![self.fileManager fileExistsAtPath:self.diskCachePath]) &#123; [self.fileManager createDirectoryAtPath:self.diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL]; &#125; // get cache Path for image key NSString *cachePathForKey = [self cachePathForKey:key]; // transform to NSUrl NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey]; [data writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil]; // disable iCloud backup if (self.config.shouldDisableiCloud) &#123; // ignore iCloud backup resource value error [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil]; &#125;&#125; 其实这个也很简单，就是简单的文件写入。 到这里，SDWebImage缓存的读写机制就介绍完了，欢迎大家勘误，SDWebImage这个库比较强大，里面还有很多细节，文中都没有提到，这里只是做了主流程的介绍，读者要是想深入的理解，还得是去阅读源码，建议的阅读的时候，和本文一起读，有助于理解源码。下一篇文章，会介绍SDWebImage是如何对图片进行编码解码的，欢迎大家阅读。]]></content>
      <categories>
        <category>技术人生</category>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>图片缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage (5.0.6) 图片加载奇淫巧技]]></title>
    <url>%2F2019%2F07%2F29%2FSDWebImage%20(5.0.6)%20%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80%2F</url>
    <content type="text"><![CDATA[最近在研究图片缓存框架，所以SDWebImage一定是我研究的不二选择，下面就简单讲述一下SDWebImage是如何加载图片的，以及加载过程中涉及到的一些骚操作。 这里先强调一点SDWebImage加载图片过程中的两个骚操作：a. 如何避免同一时间多个请求，请求同一张图片下载多次问题。b. 如何解决TableViewCell 复用时导致的图片展示错乱问题。下文中会对这两个问题给出答案，好了不扯淡了，进入正题。 当我们使用SDWebImage加载图片时需要调用如下方法：123- (void)sd_setImageWithURL:(nullable NSURL *)url &#123; [self sd_setImageWithURL:url placeholderImage:nil options:0 progress:nil completed:nil];&#125; 之后进行一系列的传递会传递到最深层的方法：1234567891011121314- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock &#123; [self sd_internalSetImageWithURL:url placeholderImage:placeholder options:options context:context setImageBlock:nil progress:progressBlock completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, cacheType, imageURL); &#125; &#125;];&#125; 可以看到，这个方法里面调用了UIView+Webcache分类里面的一个方法：12345678- (void)sd_internalSetImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context setImageBlock:(nullable SDSetImageBlock)setImageBlock progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; ...... &#125; 这个方法就是我们加载图片的正式入口方法。下面我们看一下这个方法里面都主要做了什么。第一步，根据validOperationKey 取消掉正在执行的操作operation如下调用：123456NSString *validOperationKey = context[SDWebImageContextSetImageOperationKey];if (!validOperationKey) &#123; validOperationKey = NSStringFromClass([self class]);&#125;self.sd_latestOperationKey = validOperationKey;[self sd_cancelImageLoadOperationWithKey:validOperationKey]; sd_cancelImageLoadOperationWithKey: 方法的内部实现会查询到已经存在的同名任务，并且会取消掉这个任务，并在当前view的operationDictionary 容器中移除掉。源码如下：12345678910111213141516171819- (void)sd_cancelImageLoadOperationWithKey:(nullable NSString *)key &#123;if (key) &#123; // Cancel in progress downloader from queue SDOperationsDictionary *operationDictionary = [self sd_operationDictionary]; id&lt;SDWebImageOperation&gt; operation; @synchronized (self) &#123; operation = [operationDictionary objectForKey:key]; &#125; if (operation) &#123; if ([operation conformsToProtocol:@protocol(SDWebImageOperation)]) &#123; [operation cancel]; &#125; @synchronized (self) &#123; [operationDictionary removeObjectForKey:key]; &#125; &#125; &#125;&#125; 这里需要说明一下：[self sd_operationDictionary]这个调用，这个方法的实现是给当前View通过关联对象的技术关联了一个NSMapTable对象，用来存储请求链接接对应的请求操作类型如NSMapTable&lt;NSString *, id&gt;。源码如下：1234567891011- (SDOperationsDictionary *)sd_operationDictionary &#123; @synchronized(self) &#123; SDOperationsDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey); if (operations) &#123; return operations; &#125; operations = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC); return operations; &#125;&#125; 绕了这么大一圈，你可能会问，为什么一上来要调用sd_cancelImageLoadOperationWithKey:这个方法？通过上面的源码分析SDWebImage这样设计是为了解决TableViewCell复用时，如果被复用的Cell的ImageView请求的图片没有回调时展示图片错乱的问题。原理就是如果被复用的Cell的ImageView之前请求的图片还没有回调，而此时需要请求新的图片，那么就取消掉之前的请求operation,并从operationDictionary中移除掉。然后去加载需要加载的新图片。如果说，之前的图片请求在这之后回调回来的话，会判断之前请求的operation是否存在，以及operation的isCancel属性，如果不存在或者isCancel=Yes的话，就不会回调到UI界面。也就是如下代码逻辑：12345678@weakify(operation);operation.loaderOperation = [self.imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data &#125; 说了这么多，相信应该清楚为什么要调用sd_cancelImageLoadOperationWithKey:方法了，我们接着回到sd_internalSetImageWithURL:方法中，cancel之后就会清掉当前imageView上次下载的图片：12345if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123; [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:SDImageCacheTypeNone imageURL:url]; &#125;);&#125; 这里可以解释，复用的时候，已经展示过图片的imageView为什么在被复用的时候没有展示之前存在的图片而是展示placeholer或者不展示的原因。接下来，就是判断我们传入的url是否合法，以及设置UIImageView的加载指示器，还有加载进度block，此处不做详细说明了。我们着重看加载图片的方法：123id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options context:context progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; ......&#125; 这里当前view利用前面生成的manager 去加载我们需要的图片，并把获取的结果回调给了上一级调用方。从上面的代码可以看到，获取图片的同时返回了一个operation，这个operation就是标识获取当前url图片的一个操作。之后会把这个operation放在当前view的operationDictionary中：1[self sd_setImageLoadOperation:operation forKey:validOperationKey]; sd_setImageLoadOperation：内部实现如下:1234567891011- (void)sd_setImageLoadOperation:(nullable id&lt;SDWebImageOperation&gt;)operation forKey:(nullable NSString *)key &#123; if (key) &#123; [self sd_cancelImageLoadOperationWithKey:key]; if (operation) &#123; SDOperationsDictionary *operationDictionary = [self sd_operationDictionary]; @synchronized (self) &#123; [operationDictionary setObject:operation forKey:key]; &#125; &#125; &#125;&#125; 这也是程序一开始时，能够取消掉同名operation的原因。就是同一个view发送一个图片请求就会记录在operationDictionary中来标识有请求正在执行。我们接着看loadImageWithURL:方法内部实现：首先，判断url是否合法，然后生成一个请求图片的operation，这个和我们刚才讲到的operation在内存中是同一个，因为是从该方法中返回出去的。其次，将这个operation添加到正在运行的操作容器中：123SD_LOCK(self.runningOperationsLock);[self.runningOperations addObject:operation];SD_UNLOCK(self.runningOperationsLock); 之后进入重点，那就是开始从缓存中读取图片：12// Start the entry to load image from cache[self callCacheProcessForOperation:operation url:url options:options context:context progress:progressBlock completed:completedBlock]; 同样的，将我们刚才讲到的operation传入到这个方法中。我们看一下这个方法中做了什么：123456789101112131415161718192021222324252627// Query cache process- (void)callCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation url:(nonnull NSURL *)url options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; // Check whether we should query cache BOOL shouldQueryCache = (options &amp; SDWebImageFromLoaderOnly) == 0; if (shouldQueryCache) &#123; id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter]; NSString *key = [self cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter]; @weakify(operation); operation.cacheOperation = [self.imageCache queryImageForKey:key options:options context:context completion:^(UIImage * _Nullable cachedImage, NSData * _Nullable cachedData, SDImageCacheType cacheType) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; [self safelyRemoveOperationFromRunning:operation]; return; &#125; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock]; &#125;]; &#125; else &#123; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:nil cachedData:nil cacheType:SDImageCacheTypeNone progress:progressBlock completed:completedBlock]; &#125;&#125; 从上面的源码可以看出，首先判断是否需要从缓存中读取图片，如果需要，就处理url,处理后得到我们读取缓存的key。然后，开始从缓存中读取图片，回调之后判断当前operation是否还存在，以及operation是否被取消，如果取消的话就从runningOperations中移除当前operation并返回，什么也不做。否则，调用下载处理程序：callDownloadProcessForOperation：并把我们读取出来的缓存数据传入该方法。接下来我们看看这个方法的内部实现：首先判断是否需要下载图片，如果不需要就判断缓存数据如果缓存有值就直接返回给调用方，如果需要就先看一下之前读取的缓存数据是否有值，如果有值，就直接返回给调用方。如果没有的话，就使用imageLoader下载图片：1234567891011121314151617181920212223242526272829303132333435363738// `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle@weakify(operation);operation.loaderOperation = [self.imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data &#125; else if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached &amp;&amp; [error.domain isEqualToString:SDWebImageErrorDomain] &amp;&amp; error.code == SDWebImageErrorCacheNotModified) &#123; // Image refresh hit the NSURLCache cache, do not call the completion block &#125; else if (error) &#123; [self callCompletionBlockForOperation:operation completion:completedBlock error:error url:url]; BOOL shouldBlockFailedURL = [self shouldBlockFailedURLWithURL:url error:error]; if (shouldBlockFailedURL) &#123; SD_LOCK(self.failedURLsLock); [self.failedURLs addObject:url]; SD_UNLOCK(self.failedURLsLock); &#125; &#125; else &#123; if ((options &amp; SDWebImageRetryFailed)) &#123; SD_LOCK(self.failedURLsLock); [self.failedURLs removeObject:url]; SD_UNLOCK(self.failedURLsLock); &#125; [self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock]; &#125; if (finished) &#123; [self safelyRemoveOperationFromRunning:operation]; &#125;&#125;]; 从上面的源码中可以看出请求图片的回调回来后：1.如果operation不存在或者被取消，什么也不处理2.如果有error则直接回调错误信息，并把当前url加入到filedURLs中。3.如果一切正常，则把错误请求从filedURLs中移除，并把下载好的图片数据传递到缓存处理程序。4.最后，如果finished==YES，则把当前operation从runningOperations中移除。 接下来我们看一下这个方法的内部实现：首先处理一些下载器选项，然后调用下载图片方法：1return [self downloadImageWithURL:url options:downloaderOptions context:context progress:progressBlock completed:completedBlock]; 接着看上面这个方法的内部实现：首先判断url是否合法，如果合法，从下载器的URLOperations属性中读取该url对应的operation，如果operation不存在，或者已经取消或者已经完成，则根据url重新生成一个operation,同时记录该operation到URLOperations中，并把该operation添加到下载队列中去：1234self.URLOperations[url] = operation;// Add operation to operation queue only after all configuration done according to Apple&apos;s doc.// `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.[self.downloadQueue addOperation:operation]; 如果存在operation，但是operation没有正在执行，则根据条件调整operation的请求优先级。如果有正在执行的operation，不创建新的请求operation，而是给当前operation添加回调对象progressBlock 和 completedBlock。 1id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; 看下这个方法的内部实现：12345678910- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlockcompleted:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123; SDCallbacksDictionary *callbacks = [NSMutableDictionary new]; if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy]; if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy]; SD_LOCK(self.callbacksLock); [self.callbackBlocks addObject:callbacks]; SD_UNLOCK(self.callbacksLock); return callbacks;&#125; 从中可以看出一个ImageDownloaderOperation可以有多个回调block。那么问题来了，SDWebImage为什么会这么设计呢？答案是为了解决在同一时间，多个请求同时下载一张图片的时候，对该图片请求只下载一次。也就是请求只发送一次，而请求有结果的时候根据存储的多个返回block 依次返回给调用方。这方法是不是很机智。这一点也可从请求结果的代码中得到验证：1234567891011- (void)callCompletionBlocksWithImage:(nullable UIImage *)imageimageData:(nullable NSData *)imageData error:(nullable NSError *)error finished:(BOOL)finished &#123; NSArray&lt;id&gt; *completionBlocks = [self callbacksForKey:kCompletedCallbackKey]; dispatch_main_async_safe(^&#123; for (SDWebImageDownloaderCompletedBlock completedBlock in completionBlocks) &#123; completedBlock(image, imageData, error, finished); &#125; &#125;);&#125; 从上面的代码中可以看到，方法内部是遍历了所有需要完成回调的completedBlock,然后回调出去。 到这里，SDWebImage加载图片的主要流程就已经基本讲完，本文中着重讲述了下载流程，并没有对缓存部分做详细说明，后面会抽时间完善。欢迎勘误。PS:建议在阅读本文时和源码一起阅读。]]></content>
      <categories>
        <category>技术人生</category>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>图片缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何打包一个依赖第三方framework（如支付宝的framework）的静态framework]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AA%E4%BE%9D%E8%B5%96%E7%AC%AC%E4%B8%89%E6%96%B9framework%EF%BC%88%E5%A6%82%E6%94%AF%E4%BB%98%E5%AE%9D%E7%9A%84framework%EF%BC%89%E7%9A%84%E9%9D%99%E6%80%81framework%2F</url>
    <content type="text"><![CDATA[这篇文章我们主要来探讨一下，如何让一个静态framework 依赖其他的静态framework，本文以活体检测的framework为例来一步步说明是如何实现的。 如何打包一个依赖AFNetworking的静态framework 至于如何打包一个静态库的问题，请查看本人上一篇文章： 这篇文章我们基于上一篇文章中的例子继续讲解。 第一步，我们将需要的三方framework 以及 bundle 导入到CLNetStaticFramework里面的Libs文件夹下，注意！导入的时候Add to targets 这一项一定不要勾选，只需要导入即可如图(1)。之所以这样是因为，静态库是相对独立的，不能一个静态库包含另外一个静态库，只能是依赖，这样不会造成重复引用。 图1这里需要说明的是，这里不添加到target自然不会自动生成framework path，所以需要在工程的Framework Search Paths 里面手动配置一下framework 路径如图(2)，如果不配置的话，引用的三方库头文件时会报找不到头文件错误。 图2然后是添加第三方framework需要的系统库，这里活体检测framework需要的有CoreMedia.framework,CoreMotion.framework，在Build Phases -&gt; Link Binary With Libraries 里面依次添加。另外，还需要将工程中的Enable Bitcode 设置为NO, 此时cmd+b编译一下应该可以通过了。 然后新建一个CLLiveDetect类，这里面会写一些关于活体检测的代码，并调起活体检测SDK.写一些测试代码如图(3) 图3接下来把CLLiveDetect.h暴露出来，暴露方法同上一篇文章中的方法，这里不再赘述。到这里我们就可以cmd+b来build我们的framework 了。 第二步，如何使用刚才构建好的framework? 将我们刚才build的framework 导入到ABSDKDemo工程中，重点来了！！同时也需要将活体检测的framework以及bundle 导入到该工程中。并且也要加上编译需要依赖的framework:CoreMedia.framework,CoreMotion.framework，Enable Bitcode 设置为NO, 否则的话不能通过编译。 导入完成以后cmd+b 一下你会发现工程编译成功了，然后我们运行起来看看效果。结果我们还是以Xcode控制台的日志为准（图（4））。 图4到这里，打包一个依赖第三方framework的静态库已经聊完了，欢迎大家勘误。 需要demo的朋友可以到这里去下载： CLNetStaticFramework 静态库源码 静态库测试工程 源码 欢迎star ^.^,欢迎吐槽。]]></content>
      <categories>
        <category>技术人生</category>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>静态库</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端装逼利器 zsh]]></title>
    <url>%2F2018%2F07%2F28%2FMac%E7%BB%88%E7%AB%AF%E8%A3%85%E9%80%BC%E5%88%A9%E5%99%A8-zsh%2F</url>
    <content type="text"><![CDATA[我在使用mac终端执行各种命令的时候，始终感觉不是很方便，比如在开发过程中执行git 命令的时候不清楚当前是是什么分支，得反复的git branch 查看；输入文件夹名称时候还要区分大小写，tab 键才能联想。。。为了解决这个问题，我一番google,原来有这么好用的工具 — zsh 下面我们来介绍一下zsh是如何在mac终端上面装逼的。其实zsh 也是一种sheel,但是并不是我们系统默认的 shell ,unix 衍生系统的默认shell 都是 bash. 查看已安装的shell1cat /etc/shells 可以看到总共六种123456/bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh 将默认shell改成zsh1chsh -s /bin/zsh 安装 oh my zsh手动安装：依次执行如下命令12git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 配置zsh打开配置文件1vim ~/.zshrc 设置一些常用命令的别名12345alias zshconfig=&apos;vi ~/.zshrc&apos;alias vimconfig=&apos;vi ~/.vimrc&apos;alias ll=&apos;ls -l&apos;alias vi=&apos;vim&apos;alias xcode=&apos;open -a &quot;Xcode&quot;&apos; 启用命令纠错功能1ENABLE_CORRECTION=&quot;true&quot; 插件123git osxautojump 只需要在.zshvr中启用1plugins=(git osx autojump) 到这里你可以重启一下你的终端看一下效果 再看一下git效果 有没有很惊艳！ shell的颜色配置去github 上面搜索solarized然后clone 到本地，找到对应的主题比如我们用的是Terminal终端(Mac OSX自带),就找到osx-terminal.app-colors-solarized下的三个文件,双击安装即可。 如何切换颜色打开终端的偏好设置按照下图操作即可： ok，写到这里zsh的基本玩法就结束了！欢迎大家勘误！]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的明白isKindOfClass 和 isMemberOfClass 的区别么？]]></title>
    <url>%2F2018%2F07%2F23%2F%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%98%8E%E7%99%BDisKindOfClass-%E5%92%8C-isMemberOfClass-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前几天看博客发现了一个关于 isKindOfClass 和 isMemberOfClass 的问题，但是感觉分析的不够透彻，所以我在这里试着分析一下，欢迎大家一起讨论。 内容是这样的 （如图1）。 图1上图中的四个Bool 分别是什么？ 我在这里先爆出答案：上面是个Bool 分别是：1 ，0，0，0； 那么问题来了，为毛会是这个结果？ 要弄明白这个就要搞清楚isKindOfClass 和 isMemberOfClass 的区别，先来看看官方的说法： isKindOfClass：Returns a Boolean value that indicates whether the receiver is an instance of given class or an instance of any class that inherits from that class. isMemberOfClass：Returns a Boolean value that indicates whether the receiver is an instance of a given class. 其实就是这个意思： isKindOfClass：判断对象是否为某类或其派生类的实例。 isMemberOfClass：判断对象是否为某个特定类的实例。 好，那么先来分析res1 为什么是Yes. 首先了解一下class 方法的实现 （图2） 图2从图2中可以看出[NSObject class]; 返回的其实还是NSObject,到这里你可能会想 NSObject isKindOfClass NSObject 所以 res1 = Yes。But,But,But,重要的事情说三遍，事实并非如此，接着我们来看一下isKindOfClass 方法的实现（图3） 图3以及object_getClass 的实现 （图4） 图4通过查阅objc4 源码 就是上面的图3和图4，会发现object_getClass 返回的是传入的对象的isa,由于我们传入的是类对象，所以isa 指向的是一个元类对象，那么object_getClass((id)self);返回的就是self 的元类对象，那么NSObject 类对象的元类对象是谁呢?如果你了解OC的对象模型的话会知道，NSObject的元类对象为 Meta NSObject Class Object（我们暂且这么叫） 。 回到isKindOfClass 的实现代码里，循环会先获取到NSObject的元类对象即tcls，然后跟NSObject类对象(cls)作比较,此时元类对象不等于类对象，继续循环，找到tcls-&gt;superclass,还是得熟悉OC的对象模型，NSObject 元类对象的super 就是NSObject ，没错就是它，此时 tcls 就是 NSObject 类对象，cls 也是NSObject 类对象，所以tcls 等于cls ，此时循环结束，返回Yes。 到这里不知道各位看官是否明白是怎么回事了呢？ 下面附上isMemberOfClass 的源码实现 图5 图5大家可以通过上面isKindOfClass 的分析，以及我提供的源码截图，可以分析一下其他三种res2,res3，res4的结果为什么全是0。 才疏学浅，欢迎大家勘误。多多交流，互相学习！]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中的类和元类]]></title>
    <url>%2F2018%2F07%2F23%2FObjective-C%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[你真的知道OC的类（Class）是个什么玩意儿？ 众所周知，所有的对象都是由其对应的类实例化而来，但是类本身其实也是一种对象，surprise？下面我们就来拨开这层迷雾。 类在Objective-C中，我们用到的几乎所有类都是NSObject类的子类，查阅objc源码你会发现 NSObject类定义（如图1）我们这里只给出定义其他方法大家自行查阅。 图1看完这个,那么问题来了：这个Class 类型的 isa 是个什么玩意儿？Class 又是个什么类型？带着这两个疑问我们查阅一下objc.h中Class 的定义（如图2） 图2看完这个是不是又一脸懵逼！Class 被定义为一个指向objc_class 的结构体指针。那么objc_class 又是个什么玩意儿？我们接着看源码runtime.h中定义（如图3） 图3你会发现，我艹，怎么又一个isa! 下面我们来解答这个疑惑。 其实在Objective-C中任何的类定义都是对象。即在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是苹果公司说的类对象(class object),他是一个单例(singleton), 而我们在其他面向对象语言中所谓的对象，叫做实例对象(instance object)。对于实例对象我们不难理解，但类对象(class object)是个什么鬼？我们知道Objective-C是门很动态的语言，因此程序里的所有实例对象(instace object)都是在运行时由Objective-C的运行时库生成的，而这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。 通过上面的讨论，可以得出结论，不管是实例对象，类对象，其结构中都有一个isa。实例对象中的isa 指针指向的是 该实例的类对象，那么同理，类对象的isa 指向的是谁呢？这就是 元类对象（meta class object）。他们之间的关系看起来是这样的（如图4）： 图4&gt;类对象类对象的本质通过前文我们了解到，类对象是编译器生成的“描述类定义的对象”，就是在编译时的类。任何直接或者间接继承NSObject的类，它的实例对象（instance object）中都有一个isa 指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个实例对象(instace object)所属的类的定义的一切：包括变量，方法，遵守的协议等等，这个可以通过（图3）来佐证。因此，类对象能访问所有关于这个类的信息，利用这些信息可以产生一个新的实例，但是类对象不能访问任何实例对象的内容。当你调用一个 “类方法” 例如 [NSObject alloc],你事实上是发送了一个消息给他的类对象。所谓一切皆对象就是这个意思。 那么类对象与实例对象有什么区别呢？尽管类对象保留了一个类实例的原型，但它并不是实例本身。它没有自己的实例变量，也不能执行那些类的实例的方法（只有实例对象才可以执行实例方法）。然而，类的定义能包含那些特意为类对象准备的方法–类方法（ 而不是的实例方法）。类对象从父类那里继承类方法，就像实例从父类那里继承实例方法一样。 类对象是不是就是类名？只有在消息表达式中作为接收者，类名才代表类对象。我理解为调用静态方法的时候。 元类对象元类对象的实质实际上，类对象是元类对象的一个实例。元类描述了 一个类对象，就像类对象描述了普通对象一样。不同的是元类的方法列表是类方法的集合，由类对象的选择器来响应。当向一个类发送消息时，objc_msgSend会通过类对象的isa指针定位到元类，并检查元类的方法列表（包括父类）来决定调用哪个方法。元类代替了类对象描述了类方法，就像类对象代替了实例对象描述了实例化方法一样。 很显然，元类也是对象，也应该是其他类的实例，实际上元类是根元类(root class’s metaclass)的实例,而根元类是其自身的实例，即根元类的isa指针指向自身。 类的super_class指向其父类，而元类的super_class则指向父类的元类。元类的super class链与类的super class链平行，所以类方法的继承与实例方法的继承也是并行的。而根元类(root class’s metaclass)的super_class指向根类(root class)，这样，整个isa指针链就是一个闭环。 记住，当一个消息发送给任何一个对象， 方法的检查 从对象的 isa 指针开始，然后是父类。实例方法在类中定义， 类方法 在元类和根类中定义。（根类的元类就是根类自己）。在一些计算机语言的原理中，一个类和元类层次结构可以更自由的组成，更深元类链和从单一的元类继承的更多的实例化的类。Objective-C 的类方法 是使用元类的根本原因，在其他方面试图在隐藏元类。例如 [NSObject class] 完全相等于 [NSObject self]，所以，在形式上他还是返回的 NSObject-&gt;isa 指向的元类。 Objective-C语言是一组实用的折中方案。下图表示了对象间的isa的关系，以及类的继承关系： 图片来自网络（图5）综上所述，类对象(class object)中包含了类的实例变量，实例方法的定义，而元类对象(metaclass object)中包括了类的类方法(也就是C++中的静态方法)的定义。类对象和元类对象中当然还会包含一些其它的东西，苹果以后也可能添加其它的内容，但对于我们只需要记住：类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。要注意的是，类对象(class object)和元类对象(metaclass object)的定义都是objc_class结构，其不同仅仅是在用途上，比如其中的方法列表在类对象(instance object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中则保存的是类方法(class method)。 写了这么多不知道能够拨开您心中的迷雾呢？欢迎大家勘误，互相学习！]]></content>
      <categories>
        <category>技术人生</category>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你用 Intellij IDEA 创建一个简单的SpringBoot项目]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-Intellij-IDEA-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SpringBoot%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[新建Project 默认选中 Default 点击下图的Next 按钮 填写Group、Artifact Package 那一栏和Group 保持一致就好，如果是com.jack.springtest的话会导致 WhiteLabel Error Page 异常 选中Web 选项 然后点击Next 按钮 然后点击Finish 按钮 工程结构如下： 在jack package 下新建”controller” package,在controller 下新建TestController.java,并添加如下图中的代码： 此时点击运行按钮 在地址栏输入：http://localhost:8080/hello 会有如下图输出 配置端口号 和 访问路径 再次运行 在浏览器中输入 http://localhost:8081/springboot/hello 会有上面同样的输出。]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block底层实现之逆向思维]]></title>
    <url>%2F2018%2F07%2F21%2FBlock%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[前段时间心血来潮，研究了一下block底层实现，在网上看了好多文章，基本都是通过clang 将代码转换为C++代码去分析Blcok的实现。今天我们反过来思考，用C去实现一个OC Block的效果。 Block的实现本质上是一些结构体，函数指针，函数，的综合运用。 话不多说，直奔主题： Block的实现，首先需要声明一个结构，这个结构是我们实现Block的基础，也是关键1234567891011struct __block_impl &#123;void *isa; int Flags;int Reserved;void *FuncPtr;&#125;; 说明一下： 1.isa 保存的是Block的类型 2.Flags 当block发生copy时，会用到 3.FuncPtr 指针，指向block内的函数实现（后面函数指针调用的函数） 这个结构体，是所有类型的Block都会有的一部分。 然后我们看第二个结构体1234567static struct __simpleblk_block_desc_0 &#123;size_t reserved;size_t Block_size;&#125; __simpleblk_block_desc_0_DATA = &#123;0,sizeof(struct __simpleblk_block_impl_0)&#125;; 说明一下： 1.reserved 保留字段默认是0 2.Block_size 用来保存block所占内存大小。 这个结构体用来描述block的大小等信息，simpleblk_block_desc_0_DATA是simpleblk_block_desc_0的一个结构体实例。 我们再看第三个结构体，也是Block实现最重要的结构，声明如下：12345678910111213141516171819struct __simpleblk_block_impl_0 &#123;struct __block_impl impl;struct __simpleblk_block_desc_0 *Desc;__simpleblk_block_impl_0(void *fp,struct __simpleblk_block_desc_0 *desc,int flags = 0)&#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;; 说明一下： 从这个结构中可以看到，该结构体含有 block_impl 结构的变量 和 simpleblk_block_desc_0 结构的变量，以及结构体构造函数simpleblk_block_impl_0，结构体构造函数用来初始化变量block_impl和__simpleblk_block_desc_0。 到这里，我们实现最简单的Block所需要的结构就声明完了，但是要达到OC Block 那种效果，仅有结构体 肯定是不够的。截下来我们来看一个关键的函数，你没猜错就是一个很简单的C函数：12345static void __simpleblk_block_func_0(struct __simpleblk_block_impl_0 *__cself) &#123;printf(&quot;this is charles&apos;s simple block!!&quot;);&#125; 这个函数其实就是我们的Block块里面的操作。后面调用之后就会很清楚。 到这里我们就可以写一个C函数来达到一个Block的效果： int simpleblk(){ //声明一个结构体变量1__simpleblk_block_impl_0 __simpleblk_impl0 = __simpleblk_block_impl_0((void *)__simpleblk_block_func_0,&amp;__simpleblk_block_desc_0_DATA); //声明一个函数指针变量block，并且将上面的结构体变量的地址付给block指针1void(*block)(void) = (void(*)())&amp;__simpleblk_impl0; 1234/*下面这句代码 实际上调用的是 __simpleblk_block_func_0（）函数就是函数指针调用函数。*/ 12345((void (*)(struct __block_impl *))((struct __block_impl *)block)-&gt;FuncPtr)((struct __block_impl *)block);return 1;&#125; 其实，上面写了这么多，换成OC代码其实就是在一个函数里面，声明了一个Block变量并且调用它。12345678910111213int simpleblk() &#123;void (^block)(void) = ^()&#123;printf(&quot;this is charles&apos;s block!!&quot;);&#125;;block();return 1;&#125; 到这里我们用C语言实现OC的 Block效果基本就写完了，不知道各位看官是否看明白了呢。。（PS:欢迎大家勘误，共同学习！）]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X - 重置 MySQL Root 密码]]></title>
    <url>%2F2018%2F07%2F21%2FMac%20OS%20X%20-%20%E9%87%8D%E7%BD%AE%20MySQL%20Root%20%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一：您是否忘记了Mac OS 的MySQL的root密码? 通过以下4步就可重新设置新密码：1. 停止 mysql server. 通常是在 ‘系统偏好设置’ &gt; MySQL &gt; ‘Stop MySQL Server’2. 打开终端，输入：1$ sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables 3. 打开另一个新终端，依次输入:1$ sudo /usr/local/mysql/bin/mysql -u root 1$ UPDATE mysql.user SET authentication_string=PASSWORD('新密码') WHERE User='root'; 1$ FLUSH PRIVILEGES; 1$ \q 4. 重启MySQL.*以上方法针对 MySQL V5.7.9, 旧版的mysql请使用：UPDATE mysql.user SET Password=PASSWORD(‘新密码’) WHERE User=’root’; 二：安装完mysql 之后，登陆以后，不管运行任何命令，总是提示这个：mac mysql error You must reset your password using ALTER USER statement before executing this statement.12345step 1: SET PASSWORD = PASSWORD('your new password');step 2: ALTER USER 'root'@'localhost' PASSWORD EXPIRE NEVER;step 3: flush privileges; 完成以上三步退出再登，使用新设置的密码就行了，以上除了红色的自己修改成新密码外，其他原样输入即可 12345参考1: https://dev.mysql.com/doc/refman/5.6/en/alter-user.html参考2: http://dev.mysql.com/doc/refman/5.7/en/password-expiration-policy.html参考3: http://stackoverflow.com/questions/33467337/reset-mysql-root-password-using-alter-user-statement-after-install-on-mac]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo快速搭建个人博客]]></title>
    <url>%2F2018%2F07%2F21%2Fhexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是高效的静态网站生成框架，它基于Node.js,通过编辑markdown文件来生成对应的html页面。 准备工作首先安装node.js、安装Git、注册一个github账号。 开始搭建博客开启github pages服务在GitHub上面新建一个仓库如：username.github.io 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是username+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://username.github.io的形式。 安装hexo:以上所有都安装完成之后再安装hexo.1sudo npm install hexo-cli -g 所有必须工具已经安装完成,接下来我们就可以生成博客，上传至我们的github 仓库了。 创建本地博客找一个合适的目录执行如下命令：1hexo init CharlesBlog 安装主题这里我选择的是一个比较流行的主题:next执行如下命令安装：12cd CharlesBloggit clone https://github.com/iissnan/hexo-theme-next themes/next 基础配置：打开文件位置CharlesBlog/_config.yml修改几个键值对，下面把几个必须设置的列出来按需求修改，记得保存， 还有注意配置的键值之间一定要有空格。title: CharlesBlog //你博客的名字author: Charles //你的名字language: zh-Hans //语言 中文theme: next //刚刚安装的主题名称deploy:type: gitrepository: git@github.com:icloud-art/icloud-art.github.io.gitbranch: master主题配置：主题配置文件在username.github.io/themes/next/_config.yml中修改，此处不做详细说明。 新建一篇博客进入CharlesBlog目录执行如下命令：1hexo new testblog 之后会在_post目录下面生成一个testblog.md文件，这个文件就是用来生成对应的html页面。 测试testblog执行如下命令：123hexo cleanhexo ghexo s 然后再浏览器中输入https://localhost:4000 就可以看到刚才创建的博文了（没错，就是testblog）。 安装hexo-deployer-git自动部署发布工具执行如下命令：1npm install hexo-deployer-git --save 发布工具安装好之后就可以使用1hexo d 命令来发布你的博文到GitHub.io当然完成的发布流程是这样的：1hexo clean 1hexo g 1hexo d 好，到这里你可以通过github的域名来访问你的博文了。 时间有限，本文只是简单的介绍了的博客创建流程，还有很多很好玩的配置与插件。比如说评论、标签、统计等等。各位看官慢慢的玩起来吧！]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
  </entry>
</search>
