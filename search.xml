<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Block底层实现之逆向思维]]></title>
    <url>%2F2018%2F07%2F21%2FBlock%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[前段时间心血来潮，研究了一下block底层实现，在网上看了好多文章，基本都是通过clang 将代码转换为C++代码去分析Blcok的实现。今天我们反过来思考，用C去实现一个OC Block的效果。 Block的实现本质上是一些结构体，函数指针，函数，的综合运用。 话不多说，直奔主题： Block的实现，首先需要声明一个结构，这个结构是我们实现Block的基础，也是关键1234567891011struct __block_impl &#123;void *isa; int Flags;int Reserved;void *FuncPtr;&#125;; 说明一下： 1.isa 保存的是Block的类型 2.Flags 当block发生copy时，会用到 3.FuncPtr 指针，指向block内的函数实现（后面函数指针调用的函数） 这个结构体，是所有类型的Block都会有的一部分。 然后我们看第二个结构体1234567static struct __simpleblk_block_desc_0 &#123;size_t reserved;size_t Block_size;&#125; __simpleblk_block_desc_0_DATA = &#123;0,sizeof(struct __simpleblk_block_impl_0)&#125;; 说明一下： 1.reserved 保留字段默认是0 2.Block_size 用来保存block所占内存大小。 这个结构体用来描述block的大小等信息，simpleblk_block_desc_0_DATA是simpleblk_block_desc_0的一个结构体实例。 我们再看第三个结构体，也是Block实现最重要的结构，声明如下：12345678910111213141516171819struct __simpleblk_block_impl_0 &#123;struct __block_impl impl;struct __simpleblk_block_desc_0 *Desc;__simpleblk_block_impl_0(void *fp,struct __simpleblk_block_desc_0 *desc,int flags = 0)&#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;; 说明一下： 从这个结构中可以看到，该结构体含有 block_impl 结构的变量 和 simpleblk_block_desc_0 结构的变量，以及结构体构造函数simpleblk_block_impl_0，结构体构造函数用来初始化变量block_impl和__simpleblk_block_desc_0。 到这里，我们实现最简单的Block所需要的结构就声明完了，但是要达到OC Block 那种效果，仅有结构体 肯定是不够的。截下来我们来看一个关键的函数，你没猜错就是一个很简单的C函数：12345static void __simpleblk_block_func_0(struct __simpleblk_block_impl_0 *__cself) &#123;printf(&quot;this is charles&apos;s simple block!!&quot;);&#125; 这个函数其实就是我们的Block块里面的操作。后面调用之后就会很清楚。 到这里我们就可以写一个C函数来达到一个Block的效果： int simpleblk(){ //声明一个结构体变量1__simpleblk_block_impl_0 __simpleblk_impl0 = __simpleblk_block_impl_0((void *)__simpleblk_block_func_0,&amp;__simpleblk_block_desc_0_DATA); //声明一个函数指针变量block，并且将上面的结构体变量的地址付给block指针1void(*block)(void) = (void(*)())&amp;__simpleblk_impl0; 1234/*下面这句代码 实际上调用的是 __simpleblk_block_func_0（）函数就是函数指针调用函数。*/ 12345((void (*)(struct __block_impl *))((struct __block_impl *)block)-&gt;FuncPtr)((struct __block_impl *)block);return 1;&#125; 其实，上面写了这么多，换成OC代码其实就是在一个函数里面，声明了一个Block变量并且调用它。12345678910111213int simpleblk() &#123;void (^block)(void) = ^()&#123;printf(&quot;this is charles&apos;s block!!&quot;);&#125;;block();return 1;&#125; 到这里我们用C语言实现OC的 Block效果基本就写完了，不知道各位看官是否看明白了呢。。（PS:欢迎大家勘误，共同学习！）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X - 重置 MySQL Root 密码]]></title>
    <url>%2F2018%2F07%2F21%2Fhexo-Mac%20OS%20X%20-%20%E9%87%8D%E7%BD%AE%20MySQL%20Root%20%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一：您是否忘记了Mac OS 的MySQL的root密码? 通过以下4步就可重新设置新密码：1. 停止 mysql server. 通常是在 ‘系统偏好设置’ &gt; MySQL &gt; ‘Stop MySQL Server’2. 打开终端，输入：1$ sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables 3. 打开另一个新终端，依次输入:1$ sudo /usr/local/mysql/bin/mysql -u root 1$ UPDATE mysql.user SET authentication_string=PASSWORD('新密码') WHERE User='root'; 1$ FLUSH PRIVILEGES; 1$ \q 4. 重启MySQL.*以上方法针对 MySQL V5.7.9, 旧版的mysql请使用：UPDATE mysql.user SET Password=PASSWORD(‘新密码’) WHERE User=’root’; 二：安装完mysql 之后，登陆以后，不管运行任何命令，总是提示这个：mac mysql error You must reset your password using ALTER USER statement before executing this statement.12345step 1: SET PASSWORD = PASSWORD('your new password');step 2: ALTER USER 'root'@'localhost' PASSWORD EXPIRE NEVER;step 3: flush privileges; 完成以上三步退出再登，使用新设置的密码就行了，以上除了红色的自己修改成新密码外，其他原样输入即可 12345参考1: https://dev.mysql.com/doc/refman/5.6/en/alter-user.html参考2: http://dev.mysql.com/doc/refman/5.7/en/password-expiration-policy.html参考3: http://stackoverflow.com/questions/33467337/reset-mysql-root-password-using-alter-user-statement-after-install-on-mac]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
