<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RunLoop详解]]></title>
    <url>%2F2021%2F08%2F28%2FRunLoop%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是RunLoop顾名思义，RunLoop就是运行循环，在程序运行过程中循环做一些事情。在iOS系统中RunLoop有以下应用场景： 定时器、PerformSelector CGD Async Main Queue 事件响应、手势识别、界面刷新 网络请求 AutoreleasePool 试想以下如果程序没有RunLoop会怎样？ 123456int main(int argc, const char * argv[])&#123; @autoreleasepool&#123; NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 执行完打印语句该程序就会退出运行。 那么如果有了RunLoop呢？我们看下面的代码 12345int main(int argc, char *argv[])&#123; @autoreleasepool &#123; return UIApplicationMain(argc,argv,nil,NSStringFromClass([Appdelegate class])); &#125;&#125; 这是一个APP程序的main函数，这个函数启动后APP是不会自动退出的,这是为什么呢？原因就是 UIApplicationMain 函数里面有运行循环，大致的原理跟下面的代码类似： 123456789101112int main(int argc, char *argv[])&#123; @autoreleasepool &#123; int retVal = 0; do &#123; // 睡眠中等待消息 int message = sleep_and_wait(); // 处理消息 retVal = process_message(message); &#125;while( 0 == retVal); return 0; &#125;&#125; 那么通过上面的分析我们发现RunLoop的基本作用应该是： 保持程序的持续运行 处理App中的各种事件（比如触摸事件、定时器事件等） 节省CPU资源，提高程序性能：该做事的时候做事，该休息的时候休息 …… RunLoop对象iOS中有两套API来访问和使用RunLoop Foundation: NSRunLoop Core Foundation: CFRunLoopRef NSRunLoop和CFRunLoopRef都代表着RunLoop对象 NSRunLoop是基于CFRunLoopRef的一层OC包装 CFRunLoopRef是开源的：https://opensource.apple.com/tarballs/CF/ RunLoop与线程 每条线程都有唯一的一个与之对应的RunLoop对象 RunLoop保存在一个全局的Dictionary里，线程为Key,RunLoop作为value 线程刚创建的时候没有RunLoop对象，RunLoop会在第一次获取它时创建 RunLoop会在线程结束是销毁 主线程的RunLoop已经自动获取(创建)，子线程默认没有开启RunLoop 获取RunLoop对象1234567Foundation[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象[NSRunLoop mainRunLoop]; // 或得主线程的RunLoop对象Core FoundationCFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象CFRunLoopGetMain(); // 获得主线程的RunLoop对象 RunLoop相关的类CoreFoundation中关于RunLoop的5个类 CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef 12345678typedef struct __CFRunLoop *CFRunLoopRef;struct __CFRunLoop &#123; pthread_t _pthread; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes;&#125;; 12345678typedef struct __CFRunLoopMode *CFRunLoopModeRef;struct __CFRunLoopMode &#123; CFStringRef _name; CFMutableSetRef _sources0; CFMutableSetRef _sources1; CFMutableArrayRef _observers; CFMutableArrayRef _timers;&#125; CFRunLoopModeRefCFRunLoopModeRef代表RunLoop的运行模式； 一个RunLoop包含若干个Mode,每个Mode又包含若干个Source0/Source1/Timer/Observer; RunLoop启动时只能选择其中一个Mode,作为currentMode 如果切换Mode,只能退出当前Loop,再重新选择一个Mode进入，不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响 如果Mode里没有任何Source0/Source1/Timer/Observer,RunLoop会立马退出 常见的两种Mode: kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode,通常主线程在这个Mode下运行 UITrackingRunLoopMode: 界面跟踪Mode,用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响 CFRunLoopObserverRef123456789typedef CF_OPTIONS(CFOptionFlags，CFRunLoopActivity)&#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Sources kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop kCFRunLoopAllActivities = 0x0FFFFFFFU&#125; 添加Observer监听RunLoop的所有状态12345678910111213141516171819202122232425CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault,kCFRunLoopAllActivities,YES，0，^void(CFRunLoopObserverRef observer,CFRunLoopActivity activity)&#123; switch(activity)&#123; case kCFRunLoopEntry: NSLog(@&quot;kCFRunLoopEntry&quot;); break; case kCFRunLoopBeforeTimers: NSLog(@&quot;kCFRunLoopBeforeTimers&quot;); break; case kCFRunLoopBeforeSources: NSLog(@&quot;kCFRunLoopBeforeSources&quot;); break; case kCFRunLoopBeforeWaiting: NSLog(@&quot;kCFRunLoopBeforeWaiting&quot;); break; case kCFRunLoopAfterWaiting: NSLog(@&quot;kCFRunLoopAfterWaiting&quot;); break; case kCFRunLoopExit: NSLog(@&quot;kCFRunLoopExit&quot;); break; default:break; &#125;&#125;);CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopCommonModes);CFRelease(observer); RunLoop的运行逻辑 Source0 触摸事件处理 performSelector:onThread: Source1 基于Port的线程间通信 系统事件捕捉 Timer NSTimer performSelector:withObject:afterDelay: Observers 用于监听RunLoop的状态 UI刷新(BeforeWaiting) AutoReleasePool(BeforeWaiting) 运行流程介绍： RunLoop休眠的实现原理 RunLoop在实际开发中的应用场景 控制线程的声明周期(线程保活) 解决NSTimer在滑动时停止工作的问题 监控应用卡顿 性能优化]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac终端用ClashX翻墙]]></title>
    <url>%2F2021%2F08%2F20%2FMac%E7%BB%88%E7%AB%AF%E7%94%A8ClashX%E7%BF%BB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[首先看一下你的ClashX的mixed-port是多少，方法如下图： 打开这个文件夹，然后打开config.yaml第一行就是我们要找的mixed-port,记一下这个端口号； 接下来配置终端，如果你用的是ZSH，使用CMD+Shif+. 显示隐藏文件，找到.zshrc 文件，打开后在里面加上这两句代码： 12alias proxyon=&apos;export https_proxy=http://127.0.0.1:mixed-port;export http_proxy=http://127.0.0.1:mixed-port;&apos;alias proxyoff=&apos;unset https_proxy &amp;&amp; unset http_proxy&apos; 这里为了方便使用，直接设置了别名 alias 然后保存这个文件，终端中执行source .zshrc使刚才的修改生效； 这样的话就可以试一下我们的终端是否翻墙成功了； 在终端中执行如下命令： proxyon 执行完我们就开启了代理了，那么为了证明我们翻墙成功可以使用这个代码来测试一下： curl www.google.com 如果没有数据或者长时间没有数据说明代理失败，如果有google的页面数据则说明代理成功：下面我贴一个成功的截图： 另外，还可以通过另外一个命令来查看当前的代理地址和端口配置的是哪个： echo $http_proxy 在终端输入上面的命令，会打印出你的代理IP和端口； OK，如果代理满足过你的需求之后，想关掉怎么办呢？很简单：proxyoff 在终端中输入这个命令即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS性能优化]]></title>
    <url>%2F2021%2F08%2F18%2FiOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[CPU &amp; GPU在屏幕成像的过程中CPU（Central Processing Unit，中央处理器）和GPU(Graphics Processing Unit，图形处理器)起到了至关重要的作用,简言之,CPU负责计算包括:对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片格式的转换和解码、图像的绘制（Core Graphics）。而GPU的话主要负责绘制：纹理的渲染。 两者协作的原理是这样的： 卡顿优化卡顿产生的原因屏幕显示的原理是通过两个信号：水平同步信号和垂直同步信号，每当有垂直同步信号过来的时候就会显示一帧的数据； 我们知道这每一帧的数据是通过CPU和GPU共同协作来完成的，也就是说需要在垂直同步信号到来之前CPU和GPU必须准备好要显示的这一帧的数据，那么如果没有准备完毕就会导致显示延迟也就是卡顿；可以看下这个示意图： 红色的箭头表示CPU的工作时间，蓝色的箭头表示GPU的工作时间，如果两者的工作时间超过了垂直同步信号到来的时间，就不能正常显示这一帧的图像了。那么垂直同步信号多久来一次呢？按照60FPS的刷新频率，每隔16ms就会有一个垂直同步信号过来，也就是说每一帧图像的计算和绘制要小于等于16ms，这样才不会卡； 卡顿问题如何解决OK，既然我们知道了卡顿的原因，那么我们如何避免卡顿是不是就有方向了呢？ 很显然我们要从CPU和GPU这两个方向来处理，前面已经分别讲过了二者的工作内容，那么也就是想办法降低CPU的计算时间和GPU的绘制时间。下面分别就二者的特点来总结： CPU 尽量要用轻量级对象，比如用不到事件处理的地方，可以考虑用CALayer来代替UIView 尽量不要频繁的调用UIView的相关属性，比如frame、transform、bouds等属性，尽量减少不必要的修改，降低CPU对View大小重新计算的频率； 尽量提前计算好布局，在有需要的时一次性调整对应的属性，不要多次修改属性 autolayout会比直接设置frame消耗更多的CPU资源，能用frame就不用autolayout 图片的size最好和UIImageView的size保持一致，减少CPU的计算 控制线程的最大并发数量 尽量把耗时的操作放在子线程处理：文本处理（尺寸的计算以及绘制）、图片处理（编码和绘制） GPU 尽量避免短时间内大量图片显示，尽可能的讲多张图片合并成一张来显示 GPU能处理的最大纹理尺寸是4096 * 4096,一旦超过这个尺寸就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸 尽量减少视图的数量和层级 减少透明的视图(alpha &lt; 1)，不透明的就设置opaque为YES 尽量避免离屏渲染 离屏渲染 在OpenGL中GPU有2种渲染方式 On-Screen Rendering : 当前屏幕渲染，在当前用于显示屏幕缓冲区进行渲染操作Off-Screen Rendering : 离屏渲染，在当前屏幕缓冲区以为新开辟一个缓冲区进行渲染操作 离屏渲染消耗性能的原因 需要开辟新的缓冲区 离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕(On-Screen)切换到离屏(Off-Screen)；等到离屏渲染结束后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕 哪些操作会触发离屏渲染？ 光栅化，layer.shouldRasterize = YES 遮罩，layer.mask 圆角，同时设置layer.maskToBounds = YES、layer.cornerRadius大于0；可以考虑通过CoreGraphics绘制裁剪圆角，或者叫美工提供圆角图片 阴影，layer.shadowXXX；如果设置了layer.shaowPath就不会产生离屏渲染卡顿检测 平时所说的“卡顿”主要是因为在主线程执行了比较耗时的操作 可以添加Observer到主线程RunLoop中，通过监听RunLoop状态切换的耗时，以达到监控卡顿的目的 耗电优化耗电的主要来源 CPU处理，Processing 网络，Networking 定位，Location 图像，Graphics 如何降低设备耗电 尽可能降低CPU、GPU的功耗 少用定时器 优化I/O操作： 尽量不要频繁写入小数据，最好批量一次性写入 读写大量数据时，考虑用dispatch_io,其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问。 数据量比较大的，建议使用数据库（SQLite、CoreData） 网络优化 减少、压缩网络数据 如果多次请求的结果是相同的，尽量使用缓存 使用断点续传，否则网络不稳定时可能多次传输相同的内容 网络不可用时，不要尝试网络请求 让用户可以取消长时间运行或者速度很慢的网络操作，设置合理的超时时间 批量传输，比如，下载视频时，不要传输很小的数据包，直接下载整个文件或者一大块一大块的下载。如果下载广告一次性多下载些，然后再慢慢展示；比如下载电子邮件一次性下载多封，不要一封一封的下载； 定位优化 如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务 尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest 需要后台定位时，尽量设置pauseLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新 尽量不要使用startMonitoringSignificantLocationChanges,优先考虑startMonitoringForRegion： 硬件检测优化 用户移动、摇晃、倾斜设备时，会产生动作事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件。 启动优化App 的启动可以分为两种 冷启动(Cold Launch) ：从零开始启动App 热启动(Warm Launch) ：App 已经在内存中，在后台存活着，再次点击图标启动App App启动时间的优化，主要是针对冷启动来进行优化通过添加环境变量可以打印出App的启动时间分析（Edit scheme-&gt; Run -&gt; Arguments） DYLY_PRINT_STATISTICS设置为1 如果需要更详细的信息，可以将DYLD_PRINT_STATISTICS_DETAILS设置为1 App的冷启动可以概括为3大阶段 dyld runtime main dyld(dynamic link editor)， Apple的动态链接器，可以用来装载Mach-O文件(可执行文件、动态库等)启动App时，dyld所做的事情： 装载App的可执行文件，同时会递归加载所有依赖的动态库 当dyld把可执行文件、动态库都装载完毕后，会通知runtime进行下一步的处理 启动App时，runtime所做的事情： 调用map_images进行可执行文内容的解析和处理 在load_images中调用call_load_methods，调用所有Class和Category的+load方法 进行各种objc结构的初始化(注册Objc类、初始化类对象等等) 调用C++ 静态初始化器和attribute((constructor))修饰的函数 到此为止，可执行文件和动态库中所有的符号（Class, Protocol, Selector,IMP,…）都已经按格式成功加载到内存中，被runtime所管理。 总结一把 App启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库 并由runtime负责加载成objc定义的结构 所有初始化工作结束后，dyld就会调用main函数 然后是UIApplicationMain函数，AppDelegate的application:didFinishLaunchingWithOptions:方法 App的启动优化dyld 减少动态库、合并一些动态库(定期清理不必要的动态库) 减少Objc类、分类的数量、减少Selector的数量（定期清理不必要的类、分类） 减少C++虚函数数量 Swift尽量使用struct runtime 用+initialize方法和dispatch_once取代所有的attribute((constructor))、C++静态构造器、ObjC的+load main 在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在finishLaunching方法中 按需加载 安装包瘦身安装包(IPA)主要由可执行文件、资源文件构成资源（图片、音频、视频等） 采取无损压缩 去除没有用的资源:https://github.com/tinymind/LSUnusedResources 可执行文件瘦身 编译器优化：Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO， Other C Flags添加-fno-exceptions 利用AppCode ( https://www.jetbrains.com/objc/ ) 检测未使用的代码：菜单栏-&gt;Code-&gt;Inspect Code 编写LLVM插件检测出重复代码、未被调用的代码 生成LinkMap文件，可以查看可执行文件的具体组成 可借助第三方工具解析LinkMap文件:https://github.com/huanxsd/LinkMap]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS获取设备CPU时钟频率]]></title>
    <url>%2F2021%2F08%2F04%2FiOS%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87CPU%E6%97%B6%E9%92%9F%E9%A2%91%E7%8E%87%2F</url>
    <content type="text"><![CDATA[背景 用户反馈在使用APP过程中设备发烫变卡,我猜测是因为温度过高导致CPU降频了,但是iOS系统是没有提供获取其时钟频率的接口,所以我就查资料自己尝试了一下 通过汇编语言计算得出iOS设备CPU的实时频率 下面介绍如何获取在AppDelegate.m 里面加入如下内容:1.把汇编文件cpuFrequ.s导入到项目中,将freqTest函数声明到AppDelegate.m里面;2.计算500次,然后取其中时间最少的一次,从而排除系统干扰,得到最高的频率值;3.每一次调用都是传循环参数10000，也就是执行add指令130*10000次，因此最后算频率的时候是1300000/time，也就是单位时间（s）内执行cycles的数量！！！ 123456789101112131415161718192021extern int freqTest(int cycles); static double GetCPUFrequency(void) &#123; volatile NSTimeInterval times[500]; int sum = 0; for(int i = 0; i &lt; 500; i++) &#123; times[i] = [[NSProcessInfo processInfo] systemUptime]; sum += freqTest(10000); times[i] = [[NSProcessInfo processInfo] systemUptime] - times[i]; &#125; NSTimeInterval time = times[0]; for(int i = 1; i &lt; 500; I++) &#123; if(time &gt; times[i]) time = times[i]; &#125; double freq = 1300000.0 / time; return freq; &#125; 汇编部分的代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163.text.text.align 4.globl _freqTest_freqTest:freqTest_LOOP:// loop 1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1// loop 2add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1// loop 3add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1// loop 4add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1// loop 5add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1// loop 6add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1// loop 7add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1// loop 8add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1// loop 9add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1// loop 10add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1add x1, x1, x1subs x0, x0, #1bne freqTest_LOOPRET 到这就可以测试设备的实时CPU时钟频率了,我的测试方法是将App跑起来进入一个页面,获取一下此时的时钟频率,然后在该页面执行耗CPU的操作,观测CPU的占用率达到50%左右,此时设备会发烫,持续一段时间,然后销毁这个这页面(退出页面),之后定时获取CPU时钟频率,对比数据就可以判定是不是降频了.]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于shared_preferences的本地存储]]></title>
    <url>%2F2020%2F04%2F29%2F%E5%9F%BA%E4%BA%8Eshared_preferences%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[什么是shared_preferences?shared_preferences是Flutter社区开发的一个本地数据存储的插件： 简单的，异步的，持久化的key-value存储系统； 在Android上它是基于SharedPreferences的； 在iOS上它是基于NSUserDefaults的； 如何使用shared_preferences?在pubspec.yaml文件中添加： 12dependencies: shared_preferences: ^0.5.1+1 然后执行 flutter packages get命令来安装该插件。 在需要的文件中导入： import &#39;package:shared_preferences/shared_preferences.dart&#39;; 如何存储数据： 123final prefs = await SharedPreferences.getInstance();// set value prefs.setInt(&apos;counter&apos;,counter); 如何读取数据： 12final prefs = await SharedPerferences.getInstance();final counter = prefs.getInt(&apos;counter&apos;) ?? 0; 如何删除数据： 12final prefs = await SharedPreferences.getInstances();prefs.remove(&apos;counter&apos;); shared_preferences的常用API 存储相关 12345Future&lt;bool&gt; setString(String key,String value)； Future&lt;bool&gt; setBool(String key,bool value)； Future&lt;bool&gt; setDouble(String key,double value)； Future&lt;bool&gt; setInt(String key,int value)； Future&lt;bool&gt; setStringList(String key,List value)； 如上所示，shared_preferences支持int、double、bool、string与stringList类型的数据存储； 读取相关 1234567dynamic get(String key); bool getBool(String key); double getDouble(String key); int getInt(String key); Set&lt;String&gt; getKeys(); String getString(String key); List&lt;String&gt; getStringList(String key); 以上就是shared_preferences的简单介绍。]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart语言要点]]></title>
    <url>%2F2020%2F03%2F01%2FDart%E8%AF%AD%E8%A8%80%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[对象、接口、类与mixin对象的创建每个类至少有一个构造函数，构造函数可以由开发者明确的声明，或者也可以隐式的产生。在没有明确的构造函数被声明时，隐式构造函数讲被创建，它们没有参数和函数体。 Dart实例变量初始化的几种方式： 123class Point &#123; var x = 0, y = 0;&#125; 或者使用构造函数初始化方式： 1234class Point &#123; var x , y; Point(this.x, this.y);&#125; 或者通过初始化列表： 1234class Point &#123; var x, y; Point(a,b) : x = a, y = b;&#125; 或者在构造函数中初始化： 1234class Point &#123; var x , y ; Point(a,b) &#123;x = a; y = b;&#125;&#125; 对于一个普通的实例变量，可以选择以上任意一种方式，但是最后一种方式不适用于final实例变量，因为final变量没有setter方法。final变量只能被初始化一次，所以它只能在前三种方式中选择一种。 实例的创建过程如下图所示，执行顺序按照箭头的方向： 一个构造函数的函数体在开始前总是隐含地运行父类 构造函数的函数体。 重定向构造函数重定向构造函数的目的是把执行重定向到另一个构造函数，在重定向构造函数中，参数列表跟在一个冒号后面，并以this.id(…)的形式指定重定向到哪个构造函数。 123456class Point&#123; var rho, thera; Point.polar(this.rho, this.theta); Point(a, b) : this.polar(sqrt(a * a + b * b), atan(a/b)); ...&#125; 工厂构造函数在Dart中，任意构造函数都可以被替换为工厂方法，并且对客户是完全透明的。工厂构造函数由factory前缀开头，它看起来像普通构造函数，但他们可能没有初始化列表或者初始化形式参数。相反，它们必须有一个返回对象的函数体。工厂构造函数可以从缓存中返回对象，或选择分配一个实例。它甚至可以创建一个不同类的实例。只要生成的对象符合当前类的接口，则都会按预期执行。 noSuchMethod()Dart中计算都是围绕对象方法的调用。如果调用了一个不存在的方法，则默认的行为是抛出NoSuchMethodError错误。但是，并非总是如此。 当调用一个实例中不存在的方法时，Dart运行时会调用当前对象的noSuchMethod()方法。因为Object类noSuchMethod()方法的实现就是抛出NoSuchMethodError错误。 这个方案的有点在于noSuchMethod()能够被重写。例如，如果你要实现另个一对象的代理，那你可以定义代理的noSuchMethod()方法，并把所有的调用都转发给代理的目标。 1234567class Proxy &#123; final forwardee; Proxy(this.forwardee); noSuchMethod(inv)&#123; return runMethod(forwardee, inv); &#125;&#125; 常量对象与字段Dart支持用户自定义的常量对象。 1234567class Point&#123; final x, y; const Point(this.x, this.y); ...&#125;const origin = const Point(0,0); 上面的代码中，我们已经将Point的构造函数声明为常量。一个构造函数不能有函数体，它可以有一个初始化列表，前提是只计算常量。我们仍然可以使用new调用常量构造函数，如果我们那样做，则我们传递的参数不再受限制，但结果不再是常量。 类方法类方法是不依赖与个体实例的方法。用户定义的类方法在声明它的类中是可用的，在类外只能将他们所在的类作为前缀才能访问，例如：Point.distance(aPoint,anotherPoint)。在类方法中使用this将导致编译错误。因为一个类方法不特定于任意实例，所以this在其内部是未定义的。 有一点需要说明，类变量从不被继承： 12345678910class Point &#123; static distance()&#123; &#125;&#125;class ExtendedPoint extends Point&#123; var origin = new Point(0,0); get distanceFromOrigin =&gt; distance(origin, this);// 此处会抛出NoSuchMethodError&#125; 为了使上面的代码工作，需做如下修改： 1get distanceFromOrigin =&gt; Point.distance(origin, this); 实例及实例的类与元类每个对象都是一个类的实例，既然一切都是对象，那么类也是对象；既然类是对象，那么他们本身也是某个类的实例。类的类通常被称为元类。Dart语言指定类的类型为Type,但没有指明他们属于哪个类。 上图中，aC是类C的一个实例，类C又是_Type的一个实例，_Type是它自身的一个实例。这解决了对类型可能进行无穷无尽的追溯。 Object 与其方法Object类的接口其实比较少，在前面的内容中我们了解了操作符方法 == 以及 getter方法 hashCode方法，还有runtimeType方法。而最常用的就是toString(),这个方法返回一个对象的字符串表示。我们通常都会重写这个方法以使它更有意义。所以，Object类的轮廓类似于这样： 12345678class Object &#123; external bool operator ==(other); external int get hashCode; external String toString(); external noSuchMethod(Invocation im); external Type get runtimeType;&#125; 上面的方法都被标记为external,表明他们的实现是在其他地方。external机制用于声明代码的实现来自于外部。这些外部代码可以有多种提供方式：作为底层实现基础的外部函数接口；或者甚至可以动态地生成实现。 mixinDart支持基于minxin的继承：每个类都引入了一个mxin 总结 Dart是一种基于类的纯面向对象的编程语言。这意味着运行时值都是对象，且每个对象都是某个类的实例。 对象有状态和行为。状态只能通过特殊的accessor访问：getter和setter。这确保了Dart对象上的所有计算都是通过程序接口完成的。 类在运行时才具体化，对象本身也必须如此。因此，每个类都是类型为Type的元类的一个实例。每个类都至少有一个构造函数，构造函数用于创建对象。某些对象是常量，这意味着他们在编译时就可以预先计算。 每个Dart类都有唯一的父类，除了类层级结构的根，即Object。所有Dart对象都从Object继承了共同的行为。 Dart支持基于mixin的继承：每个类都引入了一个mixin,它捕获了类本身对类层次结构所做的独特贡献。mixin使累的代码以模块化方式重用，而不依赖于他在类层级结构中的位置。 库Dart程序是由被称为库的模块化单元组成的。 顶层通常来说，一个库由多个顶层声明组成，这些声明可能定义了一个函数、变量及类型。下面是一个简单的栈库： 123456789library stack1;final _contents = [];get isEmplty =&gt; _contents.isEmtpy;get top =&gt; isEmpty ? throw 'Cannot get top of empty stack' : _contents.last;get pop =&gt; isEmpty ? trhow 'Cannot pop empty stack' : _contents.removeLast();push(e)&#123; _contents.add(e); return e;&#125; 代码中的_contents变量 就是一个顶层变量，它被初始化为一个空列表。与实例变量和类变量一样，顶层变量引入了隐含的accessor。顶层变量是延迟初始化的，与类变量一样，在他们的getter第一次调用时才执行初始化。 顶层变量和类变量一起呗称为静态变量。他们的区别在于作用域，类变量的作用域限制在声明它的类中，顶层变量的作用域覆盖了声明它的整个库。库的作用域通常由多个类和函数构成。 与类变量一样，顶层变量可以声明为final,这种情况下，他们没有定义setter且必须在声明时就初始化。也可以把静态变量声明为常量，那样的话，他们只能被赋予一个编译时常量且自身被视为不可变。 顶层函数（常被称为库方法）的作用域规则与顶层变量一样，在整个库中都是可用的，它可以是普通函数、getter、setter。 除了顶层函数与变量，也可以声明顶层类。在Dart中类声明都是顶层的，因为Dart不支持嵌套类。 隐私库是Dart的基础封装单元，以下划线_开头的成员都是库私有的。如上文中的_contents 看以下代码： 123456789class CachingClass&#123; var _cache; operator [](i)&#123; if(_cache[i] == null)&#123; _cache[i]=complicatedFunction(i); &#125; return _cache[i]; &#125;&#125; CachingClass所在的库之外的代码都无法访问_cache字段。这种方案使你不必查看某个变量的声明就可以识别它是否私有。 隐私不应该与安全混淆。Dart中的隐私是为了支持软件工程需要，而不是安全需求。唯一安全的边界在isolate之间。 导入Dart导入语句适用于任意URI(Universal Resource Indicators)。但是不推荐使用，因为位置发生变化时需要修改代码。1import 'http://staxRus/stack1.dart'; 通常我们会这样导入： 1import 'package:stack1.dart'； 这种package: 的导入方式会执行一个常驻的封装了代码位置信息的包管理器。对于平台自身的库没有必要使用package：方式，这些库通常用dart：来访问，例如1import 'dart:io'; 库内可用的对象包含了库本身所声明的对象及通过导入语句从其他库导入的对象。 库内的可用对象与它提供给客户的对象是不同的。从库外部导入的对象对库的用户是不可用的。此外，库的私有成员对库的调用者是不可用的。 解决库内倒入的成员冲突的方法是为这些库提供不同的前缀来进行区分。 12import 'package:stack1.dart' as stack1;import 'package:stack2.dart' as stack2; 导入库的前缀不得与本库内其他顶层变量声明发生冲突。否则编译器会标记错误，因为本地变量的优先级高于所有导入的对象。 Dart提供了额外的机制来控制导入到库内的对象：命名空间组合器show和hide。命名空间是名称到声明的映射。 hide组合器接收一个命名空间和一个标识符列表，并将标识符列表中的对象从命名空间中丢弃，然后产生一个新的命名空间。如下： 12library lib1;import 'stack1.dart' hide isEmpty, top; hide操作符被应用到导出的命名空间中，将isEmpty 和 top 移除了。实际提供给导入这作用域的是hide操作符用用之后的结果。show组合器类似，只有在标识符列表中的对象会被保留。如下： 12library lib1;import 'stack1.dart' show pop, push; 如果你真的想让自己的库健壮，那么你应该组合使用前缀和show,只导入你实际使用的元素： 12library lib1;import 'stack1.dart' as stack1 show pop,push; 使用show将防止导入的新成员有意外冲突。而采用上面的方式，可以解决不同倒入成员之间的冲突，并提防倒入成员和继承成员之间的冲突。 将库拆分成part有时，一个库可能太大，不能方便的保存在一个文件中。Dart允许把库拆分成较小的part组件。每个子功能或者子系统都放在各自的文件中，而库通过使用part指令来引用他们。 part指令看起来跟C语言的#include类似。但事实并非如此，每一个part都必须以一个part头来指定它属于哪一个库。例如： 1234part of ide;// 顶层声明 class ClassBrowser...... part的头部使用库名称来指明它所在的库。不是所有的库都有名称，但是如果使用part来构建库，那么库本身必须要命名。各个part应该有很好的结构，并且按照逻辑分组，而不是纯粹的堆积代码。 一般的规则是，如果库通过URI引用某个part,而URI的内容并不是一个part,那么这就是一个编译错误，而如果part本身不指向同一个库，那么会产生一个警告。 导出导出指令允许一个库使用来自其他命名空间的对象来扩充自己的导出命名空间。 export &#39;browsing.dart&#39; 还可以使用show和hide对库的命名空间进行合理的过滤。 export &#39;vcs.dart show RepositoryBrowser&#39;; 导出的规则与导入、part的规则相同。 钻石导入从多个聚合性API导入时，可能会从不同的路径导入相同的对象，这种情况被称为钻石导入。Dart会对钻石导入发出警告。 延迟加载延迟加载的作用：一是应用快速启动且保持下载量尽可能的小。另外，在拥有诸多功能的大型应用中，延迟加载可以减少内存的使用。 1import &apos;rarelyUsed.dart&apos; deferred as rarelyUsed; 延迟加载的导入必须提供前缀，且前缀不能被库中的其他导入使用。违反这些规则将会导致编译错误。 总结Dart程序由库组成。库聚合类、函数和变量。Dart的库是针对隐私而不是安全性封装单元。 Dart程序的执行总是从脚本的main()函数开始的。一个库可以被拆分成多个part。Dart库通过导入来接入他们自身的依赖，并能通过执行命名空间组合器来选择性地导入其他库的对象，也能够通过添加前缀来区分各个导入。库通过命名空间组合器也能将其他库或自己的部分内容重新导入。库可以延迟到运行时加载，以改善启动时间及减少不必要的内存开销。 函数函数是Dart的主力，所有计算都是由函数来执行。我们将所有语法形式的函数与方法统称为函数。 函数是Dart存储在变量中的一等值，它能作为参数传递，作为函数的返回值。函数同样是对象。 参数函数总是有一个形式参数列表，这个列表页可以为空。参数要么是位置型的，要么是命名型的。 位置参数位置参数可以是必填的或可选的。可选参数必须排列在一起放置在参数列表尾部，并用方括号[]包裹。任意必填参数都必须出现在可选参数前面。可选参数可以指定默认值但必须是编译时常量。1increment(x,[step = 1]) =&gt; x + step; // step 是可选的，默认值是1 命令参数命名参数要在位置参数之后声明，并用大括号{}包裹。 示例1addressLetter(&#123;name:'', street:'', number,city,zip,country&#125;)&#123;...&#125; 下面是一个必填参数与命名参数混合的例子： 12345678var map = new Map();fail() =&gt; throw('Key not found');lookup(key,&#123;ifMissing: fail&#125;)&#123; var result = map[key]; if(result == null)&#123; return ifMissing(); &#125;&#125; 通常，作为错误处理程序的回调函数会通过命名参数来指定。 如果可选参数没有指定默认值，则它的值默认是null。 命名参数始终是可选的，不可以混合使用可选位置参数和命名参数。 形式参数不是fianl变量，他们可以被修改，但这不是一个好的风格，我们应该尽量减少使用可变的变量。 函数体Dart的函数体有两种形式： 大括号{}括起来的语句列表(可以为空)。 =&gt; 符号后跟着一个表达式。 构造函数包括了工厂构造函数与生产构造函数，其中工厂构造函数是具备特殊功能的普通函数。生产构造函数与工厂构造函数的区别在于，它始终返回一个新的实例或者抛出一个异常。所以就算是没有显式的使用return语句，生产构造函数也不会返回null。 函数声明函数声明有一个函数名称，后面跟着参数列表和函数体。 抽象方法有函数签名但是没有函数体。 函数声明可以出现在顶层(如，main()),或者作为方法存在，而且，函数可以是局部函数。局部函数就是定义在其他函数内部的函数。 1234567891011fib(n)&#123; lastTwo(n)&#123; if(n &lt; 1) &#123; return [0,1]; &#125;else &#123; var p = lastTwo(n - 1); return [p[1], p[0] + p[1]]; &#125; &#125; return lastTwo(n)[1];&#125; 闭包函数可以定义在表达式内部，他们被称为函数字面量，或者被称为闭包。与函数生命不同，闭包没有名称。但是他们也有参数列表和函数体。 1234(x) =&gt; x;(x) &#123;return x;&#125;(x, [step = 1]) =&gt; x + step; // 有一个可选参数的闭包(a, b) =&gt; a + b; // 有两个必填参数的闭包 调用方法与函数级联除了使用点运算符来执行成员选择，Dart也支持使用双点运算符进行方法级联。例如: 12"Hello".length.toString(); // 值为'5'"Hello"..length.toString(); // 值为 'Hello' 所以下面的代码我们可以换一种写法： 1234var address = new Address.of("Charles");address.setStreet("Elm", "13a");address.city = "Carthage";address.state = "Eurasia"; 使用级联的写法：1234new Address.of("Charles"); ..setStreet("Elm", "13a") ..city = "Carthage" ..state = "Eurasia"; 不应当滥用级联，比如，不应当把一系列级联放在同一行或是使用过多层次的级联。 级联对构建建造者模式API非常有用，即 一个对象描述符被分步创建，在经历一系列级联后，对象在构建结束时才被创建。 另一种能用到级联的情况是，当我们执行某个对象的方法时，我们需要的返回值是对象本身。 赋值可能并不明显，但Dart中的赋值通常都是函数调用，因为对字段的赋值只是setter 方法的语法糖而已。 使用运算符Dart支持用户自定义的运算符，用户自定义的运算符是加上是有着特殊语法的实例方法，这些方法必须使用内置标识符operator作为前缀。 Function 类Function是代表所有函数的公共顶层接口的抽象类。Function没有声明任何实例方法。然而他声明了类方法apply(),此方法接收一个函数和一个参数列表，并使用提供的参数列表去调用传入的函数。 apply()的签名是： 1static apply(Function function, List positionalArguments, [Map&lt;Symbol, dynamic&gt; namedArguments]); apply()方法提供了一种使用动态确定的参数列表来调用函数的机制。通过这我们可以处理在编译时参数列表数量不确定的情况。 函数作为对象在Dart中，函数当然也是对象。 实际上，一个函数表达式每被计算一次，就可能分配一个新的函数对象。同样，局部函数的声明每次被新的动态作用域包含时，就会引入一个新的对象。 12345makeCounter()&#123; var counter = 0; increment()=&gt; ++counter; return increment;&#125; 每次对increment的调用都返回一个不同的increment函数。 总结 与其他运行时的值一样，函数也是对象。Dart中的函数可以接收位置或命名参数。位置参数可以是必填或可选的，命名参数始终是可选的。 函数始终遵循词法作用域且对周边环境是封闭的。 Dart函数既能作为类的方法也能作为独立的结构。独立的函数可以在库级别声明。 所有内置的操作符也都是函数，且他们大部分都被定义为实例方法，可以被开发者重写。用户定义的类可以通过实现特殊的call方法来模拟内置函数类型。所有Dart函数都被认为是Function类型的成员。]]></content>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter开发包和插件]]></title>
    <url>%2F2020%2F02%2F17%2FFlutter%E5%BC%80%E5%8F%91%E5%8C%85%E5%92%8C%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[介绍一下包使用package可以创建共享的模块化代码。一个最小的package包括： 一个pubspeck.yaml文件：声明了package的名称、版本、和作者等的元数据文件。 一个lib文件夹：包括公开的pubulic代码，最少应该有一个&lt;package-name&gt;.dart文件。 Flutter Packages分为两类： Dart包：其中一些可能包含Flutter的特定功能，因此对Flutter框架具有依赖性，这种包仅用于Flutter。 插件包：一种专用的Dart包，其中包含Dart编写的API,以及针对安卓和iOS平台的特定实现，就是说插件包括原生代码。 开发Dart Packages第一步创建Dart包你可以使用如下命令创建DartPackages 1flutter create -template=package charles_package 这将在charles_package/文件夹下创建一个具有以下专用内容的package工程： lib/mypackage.dart: Package的Dart代码 test/charles_package_test.dart: Package的单元测试代码。 实现Package对于纯Dart包，只需要在lib/.dart文件内或lib目录中的文件中添加功能即可。要测试软件包，请在test目录中添加unit tests。 下面我们看看如何组织package包的代码，以shelf package为例，它的目录结构如下： 在lib根目录下的shelf.dart中导出了多个lib/src目录下的dart文件： 12345678910export 'src/cascade.dart';export 'src/handler.dart';export 'src/handles/logger.dart';export 'src/hijack_exception.dart';export 'src/middleware.dart';export 'src/pipleline.dart';export 'src/request.dart';export 'src/response.dart';export 'src/server.dart';export 'src/server_handler.dart'; 而package中主要的功能源码都在src下。shelf package也导出了一个mini库：shelf_io，它主要是处理HttpRequest的。 导入包，当需要使用这个package时，我们可以通过package：指令来指定包的入口文件： 1import &apos;pakcage:utilities/utilities.dart&apos;; 同一个包中的源码文件之间也可以使用相对路径来导入。 生成文档可以使用dartdoc工具来为package生成文档，开发者需要做的就是遵守文档注释语法在代码中添加文档注释，最后使用dartdoc可以直接生成API文档（一个静态网站）。文档注释是使用三斜线’///‘开始，如： 1234/// The event handler responseible for updating the badge in the UI.void updateBadge()&#123; ...&#125; 处理包的相互依赖如果我们正在开发一个charles_package包，它依赖于另一个包，则需要将该依赖包添加到pubspec.yaml文件的dependencies部分。这与在Flutter 应用程序或任何其他Dart项目中引用软件包没有什么不同。但是，如果charles_package包碰巧是一个插件包，其平台特定的代码需要访问url_launcher公开的特定于平台的API，那么我们还需要为特定于平台的构建文件添加合适的依赖声明，如下所示： Android 在charles_package/android/build.gradle: 12345android&#123; dependencies&#123; provided rootProject.findProject(&quot;:url_launcher&quot;) &#125;&#125; 您现在就可以在charles_package/android/src源码中import io.flutter.plugins.urllauncher.UrlLauncherPlugin访问UrlLauncherPlugin类。 iOS 在charles_package/ios/charles_package.podspec: 12Pod::Spec.new do |s| s.dependency &apos;url_launcher&apos; 你现在就可以在charles_package/ios/classes源码中 #import &quot;UrlLauncherPlugin.h&quot; 然后访问UrlLauncherPlugin类。 解决依赖冲突假设我们想在charles_package包中使用some_package 和 other_package，并且这两个包都依赖url_launcher,但是依赖的是url_launcher的不同版本。那我们就有潜在冲突。避免这种情况的最好方法是在指定依赖关系时，使用版本范围而不是特定版本。 123dependencies: url_launcher:&apos;^0.4.2&apos; image_picker:&apos;0.1.1&apos; 如果some_package声明了上面的依赖关系，other_package声明了url_launcher版本像’0.4.5’或’^0.4.0’时，pub将能够自动解决问题。 即使some_package和other_package声明了不兼容的url_lancher版本，它仍然可能会和url_launcher以兼容的方式正常工作。你可以通过向charles_package包的pubspeck.yaml文件中添加依赖性覆盖声明来处理冲突，从而强制使用特定版本： 强制使用0.4.3版本的url_lancher,在charles_package/pubspec.yaml中： 12345dependencies: some_package: other_package:dependency_overrides: url_launcher:&apos;0.4.3&apos; 如果冲突依赖不是一个包，而是一个特定于Android的库，比如guava,那么必须将依赖重写声明添加到Gradle构建逻辑中。 强制使用23.0版本的guava库，在charles_package/android/build.gradle中： 12345configurations.all&#123; resolutionStrategy&#123; force &apos;com.google.guava:guava:23.0-android&apos; &#125;&#125; Cocoapods目前不提供依赖覆盖功能。 发布Package一旦实现了一个包，我们可以在Pub上发布它，这样其他开发者可以轻松使用它。 在发布前，检查pubspec.yaml、README.md以及CHANGELOG.md文件，以确保其内容的完整性和正确性。然后运行dry-run命令以查看是否都准备好了。 1flutter packages pub publish --dry-run 验证无误后，我们就可以运行发布命令了： 1flutter pakcages pub publish]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter使用Packages]]></title>
    <url>%2F2020%2F02%2F16%2FFlutter%E4%BD%BF%E7%94%A8Packages%2F</url>
    <content type="text"><![CDATA[使用 Flutter PackagesFlutter 支持使用其他开发者在Flutter和Dart生态系统中共享的包。这可以使你快速的构建一个应用而不必从头开发一切。这篇文章我来介绍一下如何使用已经发布的packages。 查找包使用一个包之前，首先得找到这个包，我们可以访问pub.dev来查找你需要的包。 添加一个包到项目中添加 css_colors 包到一个项目中有如下步骤: 添加依赖: 打开pubspec.yaml文件，在dependencies下面添加css_colors。 安装依赖：使用终端 cd 到你的项目目录下执行flutter pub get命令,或者在pubspec.yaml顶部点击Packegets get。 导入你添加的包：在你的Dart代码中添加一个正确的 import 语句。 如果需要的话，重启或者停止你的应用：因为热重载和热重启只作用于Dart代码，不会作用于平台特定代码。在使用包的时候做一个重启应用可以有效的避免以下错误。 冲突解决试想一下，如果你在一个应用中想使用 some_package 和 another_package两个包，而这两个包都依赖于url_launcher的不同版本。这就会造成包的版本依赖冲突。那么这种情况我们该如何解决呢？最好的方法来避免这个问题就是在指定依赖的时候使用版本范围而不是一个指定的版本。 123dependencies: url_launcher：^0.4.2 # 任意的0.4.x版本，当x&gt;=2时都生效。 image_picker：‘0.1.1’ # 只有0.1.1版本生效。 如果some_package声明了上面的依赖项，而另一个_package声明了一个兼容的url_launcher依赖项，比如’0.4.5’或^0.4.0，那么Pub会自动解决这个问题。平台对Gradle模块和/或CocoaPods的特定依赖也以类似的方式解决。 即使some_package和another_package声明url_launcher的版本不兼容，它们实际上可能以兼容的方式使用url_launcher。在这种情况下，可以通过在应用程序的pubspec.yaml文件中添加依赖项覆盖声明来解决冲突，强制使用特定的版本。 强制使用url_launcher 0.4.3 版本修改如下代码： 12345dependencies: some_package: another_package:dependency_overrides: url_launcher: &apos;0.4.3&apos; 开发新包如果现有的包满足不了你的特定需求，你可以开发一个自定义的包。下篇文章我们会讲述如何开发一个新包和插件。 管理包依赖和版本为了是冲突的风险最低，我们可以在pubspec.yaml中指定一个版本范围。为了确保应用在包更新时不会中断，我们可以使用以下方式来指定包版本范围： 指定最小和最大的版本的范围约束： 12dependencies: url_launcher: &apos;&gt;=0.1.2 &lt;0.2.0&apos; 使用插入符号语法的范围约束： 12dependencies: collection: &apos;^0.1.2&apos; 更新包依赖当你添加完包以后，第一次使用flutter pub get的时候，Flutter 保存了具体的包版本号在pubspec.lock 文件中。这个确保你和你的团队成员在执行flutter pub get 命令时可以得到同样版本的包。 升级一个包的新版本，例如要使用一个包的新特性，执行flutter pub upgrade来获取pubspec.yaml中版本约束中允许的最高可用版本的包。 依赖没有发布的包没有发布到pub.dev的包也可以用。对于私有的插件，或者没有准备好发布的包，可以使用附加的依赖项选项： Path dependency: 一个Flutter 应用可以通过一个文件系统路径依赖一个插件，路径可以是相对的或者绝对的。例如要依赖一个位于应用统计目录的插件plugin1,可以使用如下语法： 123dependencies: plugin1: path: ../plugin1/ Git dependency:你也可以使用一个存储在git版本库中的包，如果包位于repo的根目录，使用如下语法： 1234dependencies: plugin1: git: url: git://github.com/flutter/plugin1.git Git dependency on a package in a folder:Pub假定包在Git存储仓库的根目录中，如果不是的话，使用path参数来指定路径，例如： 12345dependencies: package1: git: url: git://github.com/flutter/packages.git path: packages/package1 最后，可以使用ref 参数将依赖项固定到特定的git提交，分支或者tag。 到这里，关于Flutter包的使用已经介绍完了，为了方便理解呢，我还是附上一个例子：Flutter包的使用。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS和Flutter通信初探]]></title>
    <url>%2F2020%2F02%2F15%2FiOS%E5%92%8CFlutter%E9%80%9A%E4%BF%A1%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[Flutter 使用了一套灵活的系统来调用平台特定的APIs,无论是iOS还是安卓。Flutter支持平台特定API不是依赖于生成代码的方式，而是通过灵活的消息传递。 应用的Flutter部分发送消息到它的宿主（应用的iOS或者Android部分）通过，platform channel. 应用宿主在platform channel上面监听并且接受消息。然后调用任意数量的特定平台的API（通过原生语言），然后发送一个回调给到Flutter 部分。注意 如果您需要使用Java/Kotlin/Objective-C或Swift中的平台api或库，本文将介绍如何使用平台通道机制。但是，通过检查defaultTargetPlatform属性，您还可以在Flutter应用程序中编写特定于平台的Dart代码。平台适配列出了一些特定于平台的适配，这些适配会在框架中自动执行Flutter。平台渠道的架构概述使用平台通道在客户端(UI)和主机(平台)之间传递消息，如下图所示: 消息和响应是异步传递的，以确保用户界面保持响应性。 尽管Flutter是异步地向Dart发送消息，但无论何时调用channel方法，都必须在平台的主线程上调用该方法。 在客户端，MethodChannel (API)允许发送与方法调用对应的消息。在平台端，Android上的MethodChannel (API)和iOS上的FlutterMethodChannel (API)支持接收方法调用和发送结果。这些类允许您用很少的“样板”代码开发平台插件。 平台通道数据类型支持和编解码器 标准平台通道使用标准消息编解码器，该编解码器支持对简单的json类值(如布尔值、数字、字符串、字节缓冲区以及这些值的列表和映射)的高效二进制序列化(有关详细信息，请参阅StandardMessageCodec)。当您发送和接收值时，这些值与消息之间的序列化和反序列化将自动发生。 下表显示了在平台端接收Dart值的方式，反之亦然。 好了，原理介绍完了，下面一起来看一下具体是如何跑起来的。参照官方文档做了一个在iOS平台获取手机电量的例子。这个例子会示范如何调用平台特定的API来检索以及展示当前设备的电量。它将会使用Android BatteryManager API,和iOS device.batteryLevel API,通过一个单独的平台方法，getBatteryLevel()。 创建一个flutter工程使用如下命令创建：1flutter create platform_channel 或者你可以通过设置特定的语言来指定默认的模板：1flutter create -i objc -a java platform_channel 使用你安装的编译器来打开创建好的工程，我使用的是idea,然后在你工程中的main.dart里面添加如下代码： 123456789101112131415161718class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; // 创建client和host通信的通道 static const platform = const MethodChannel('charles.flutter.dev/battery'); String _batteryLevel = 'Unknown battery level.'; // 获取电量方法 Future&lt;void&gt; _getBatteryLevel()async&#123; String batteryLevel; try&#123; final int result = await platform.invokeMethod('getBatteryLevel'); batteryLevel = 'Battery level at $result % .'; &#125;on PlatformException catch(e)&#123; batteryLevel = "Failed to get battery level: '$&#123;e.message&#125;'."; &#125; setState(() &#123; _batteryLevel = batteryLevel; &#125;); &#125;&#125; 简单解释一下：首先创建了platform 实例，这个就是通信的通道。client 和 host之间通过通道名称进行连接。单个应用中使用的所有通道名称必须是唯一的，给通道名字添加域前缀，例如：charles.flutter.dev/battery。_getBatteryLevel()方法就是异步的获取当前设备电量的方法。这个方法中最核心的一句： 1final int result = await platform.invokeMethod(&apos;getBatteryLevel&apos;); 就是通过通道，去调用host端的getBatteryLevel方法，并且把获取到的值但会到client端。 展示电量的部分就不介绍了。大家可以看下文附的Demo. host端的话，只介绍iOS端了，安卓类似。有兴趣的朋友可以自己看看。从flutter 项目目录下找到 ios/Runner.xcworkspace 双击打开。在Appdelegate 里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#import &lt;Flutter/Flutter.h&gt;#import "GeneratedPluginRegistrant.h"@implementation AppDelegate- (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions &#123; FlutterViewController* controller = (FlutterViewController*)self.window.rootViewController; FlutterMethodChannel* batteryChannel = [FlutterMethodChannel methodChannelWithName:@"samples.flutter.dev/battery" binaryMessenger:controller]; __weak typeof(self) weakSelf = self; [batteryChannel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) &#123; // Note: this method is invoked on the UI thread. if ([@"getBatteryLevel" isEqualToString:call.method]) &#123; int batteryLevel = [weakSelf getBatteryLevel]; if (batteryLevel == -1) &#123; result([FlutterError errorWithCode:@"UNAVAILABLE" message:@"Battery info unavailable" details:nil]); &#125; else &#123; result(@(batteryLevel)); &#125; &#125; else &#123; result(FlutterMethodNotImplemented); &#125; &#125;]; [GeneratedPluginRegistrant registerWithRegistry:self]; return [super application:application didFinishLaunchingWithOptions:launchOptions];&#125;- (int)getBatteryLevel &#123; UIDevice* device = UIDevice.currentDevice; device.batteryMonitoringEnabled = YES; if (device.batteryState == UIDeviceBatteryStateUnknown) &#123; return -1; &#125; else &#123; return (int)(device.batteryLevel * 100); &#125;&#125;@end 解释一下：这段代码也是先创建一个通道 batteryChannel，可以看到这里使用的channel name 和上文中提到的 client 端里面的完全一致。同时设置了消息的发送者。 getBatteryLevel 就是iOS获取电量的方法，不做过多解释，到此为止，你可以运行platform_channel flutter项目来看一下是否可以获取到当前手机的电量。 效果如下： 以上介绍的就是利用MethodChannel从Flutter端调用平台端函数的方法。接下来我们介绍一下如何从平台端调用Flutter端的函数，我们需要在平台端代码部分编写如下方法： 12345- (void)invokeFlutterMethod:(FlutterMethodChannel *)channel &#123; [channel invokeMethod:@"flutterMethod" arguments:nil result:^(id _Nullable result) &#123; NSLog(@"result is %@",result); &#125;];&#125; 在调用返回电量结果后，调用该方法，为了效果明显我们延迟3秒钟调用: 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [weakSelf invokeFlutterMethod:blockChannel]; &#125;); 而在Flutter端需要编写如下代码，在build方法中添加监听： 1_platform.setMethodCallHandler(platformCallHandler); 实现platformCallHandler和flutterMethod方法： 12345678910111213Future&lt;dynamic&gt; platformCallHandler(MethodCall call) async &#123; switch (call.method) &#123; case "flutterMethod": flutterMethod(); break; &#125; &#125; void flutterMethod()&#123; setState(() &#123; _batteryLevel = '已经获取到电量了！！！'; &#125;); &#125; 然后再次运行程序，当获取完电量后3秒，按钮下方的文字会变成”已经获取到电量了!!!”(此处就不再提供Gif了) 附：本文的Demo]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Dart</tag>
        <tag>Flutter</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS混合Flutter初探]]></title>
    <url>%2F2020%2F02%2F13%2FiOS%E6%B7%B7%E5%90%88Flutter%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[由于最近公司项目里面要用到Flutter，故研究了一番iOS和Flutter是如何在一起工作的。下面我们就一步步的来介绍一下：开发环境在你心爱的Mac上面安装好Flutter 1.12.13+hotfix.8 • channel stable •、Xcode 11.2.1。 提示：Flutter 支持到iOS8以上。 首先要创建一个iOS项目ios_flutter_hybrid 这里就不再详细介绍该项目是如何创建的了。然后集成flutter_module到iOS项目中,flutter 可以作为一个framework嵌入到现有的iOS项目中。要将flutter嵌入到现有的iOS工程中，首先要创建一个flutter_module,它的目录位置最好和项目目录是平行的。执行如下命令： 12cd ios_flutter_hybridflutter create -t module flutter_module 出现如下log就说明执行成功了： 123456789101112131415161718Creating project flutter_module... flutter_module/test/widget_test.dart (created) flutter_module/flutter_module.iml (created) flutter_module/.gitignore (created) flutter_module/.metadata (created) flutter_module/pubspec.yaml (created) flutter_module/README.md (created) flutter_module/lib/main.dart (created) flutter_module/flutter_module_android.iml (created) flutter_module/.idea/libraries/Flutter_for_Android.xml (created) flutter_module/.idea/libraries/Dart_SDK.xml (created) flutter_module/.idea/modules.xml (created) flutter_module/.idea/workspace.xml (created)Running &quot;flutter pub get&quot; in flutter_module... 2.0sWrote 12 files.All done!Your module code is in flutter_module/lib/main.dart. 嵌入flutter module 到现有工程中有两种方式将Flutter嵌入到项目中1.使用pod install 安装（推荐使用） （配置一下podfile下面会讲解）2.你编译好一个framework，然后手动嵌入到项目中，并且好手动更新编译配置。注意和Flutter 混合的应用不可以在simulator 上面运行Release模式，因为flutter 不支持为Dart代码提前输出x86二进制文件。你可以在模拟器或真机上面运行Release模式。 我选择的是使用pod来嵌入flutter framework. 需要说明的是flutter 模块的目录和应用程序的目录是平行的，否则可能需要调整相对路径。目录结构如下： 1234567some/path/├── flutter_module/│ └── .ios/│ └── Flutter/│ └── podhelper.rb└── ios_flutter_hybrid/ └── Podfile 如果新创建的项目没有podfile 就创建一个podfile。然后在podfile里面添加如下代码： 123456flutter_application_path = &apos;../flutter_module&apos;load File.join(flutter_application_path, &apos;.ios&apos;, &apos;Flutter&apos;, &apos;podhelper.rb&apos;)target &apos;ios_flutter_hybrid&apos; do install_all_flutter_pods(flutter_application_path)end 对于每一个需要嵌入flutter的podfile 目标，调用 install_all_flutter_pods(flutter_application_path) 方法。接下来只需要执行 pod install 即可。 注意当你在pubspec.yaml中修改了flutter plugin的依赖关系，在flutter module目录下运行flutter pub get 命令来更新podhelper.rb脚本读取的插件列表。然后执行pod install 来安装更新。podhelper.rb脚本将你的plugin、Flutter.framework、App.framework嵌入到工程中。此时，你就开打开ios_flutter_hybrid.xcworkspace 来运行混合好的项目了。 添加一个flutter 页面进入到上面的工程中首先要在Appdelegate里面创建一个FlutterEngine如下代码： 123456@import UIKit;@import Flutter;@interface AppDelegate : FlutterAppDelegate // More on the FlutterAppDelegate below.@property (nonatomic,strong) FlutterEngine *flutterEngine;@end 实现部分： 1234567891011121314#import &quot;AppDelegate.h&quot;#import &lt;FlutterPluginRegistrant/GeneratedPluginRegistrant.h&gt; // Used to connect plugins.@interface AppDelegate ()@end@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. self.flutterEngine = [[FlutterEngine alloc] initWithName:@&quot;my flutter engine&quot;]; // Runs the default Dart entrypoint with a default Flutter route. [self.flutterEngine run]; [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine]; return [super application:application didFinishLaunchingWithOptions:launchOptions];&#125; 接下来我们在ViewController里面写一个点击事件来吊起一个Flutter页面。在ViewController的viewDidLoad方法中添加如下代码： 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; // Make a button to call the showFlutter function when pressed. UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button addTarget:self action:@selector(showFlutter) forControlEvents:UIControlEventTouchUpInside]; [button setTitle:@&quot;Show Flutter!&quot; forState:UIControlStateNormal]; button.backgroundColor = UIColor.blueColor; button.frame = CGRectMake(80.0, 210.0, 160.0, 40.0); [self.view addSubview:button];&#125; 同时实现一个showFlutter方法: 1234567- (void)showFlutter &#123; FlutterEngine *flutterEngine = ((AppDelegate *)UIApplication.sharedApplication.delegate).flutterEngine; FlutterViewController *flutterViewController = [[FlutterViewController alloc] initWithEngine:flutterEngine nibName:nil bundle:nil]; [self presentViewController:flutterViewController animated:YES completion:nil];&#125; 此时运行一下工程查看效果。不出意外的话你会成功的调起来一个Flutter 页面。 混合项目如何调试混合的项目也是可以使用flutter的热更新以及热重启的。接下来我们就介绍一下如何使用这个功能。 首先将混合好的项目运行到手机上，进入flutter页面。 然后cd 到flutter_module目录下，执行flutter attach命令。如果打印的有如下日志，则说明成功了： 123456 Syncing files to device Charles的iPhone... 4,694ms (!) 🔥 To hot reload changes while running, press &quot;r&quot;. To hot restart (and rebuild state), press &quot;R&quot;.An Observatory debugger and profiler on Charles的iPhone is available at: http://127.0.0.1:1024/RkN8tMSDSoE=/For a more detailed help message, press &quot;h&quot;. To detach, press &quot;d&quot;; to quit, press &quot;q&quot;. 接下来就可以愉快的开发调试界面了。 本文Demo代码 下篇文章我们一起来探讨flutter 和 原生iOS代码之间是如何通信的。 欢迎勘误！]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Dart</tag>
        <tag>Flutter</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底解决pod install龟速问题]]></title>
    <url>%2F2020%2F02%2F08%2F%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3pod-install%E9%BE%9F%E9%80%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近由于疫情严重，我司果断安排在家办公，在配置开发环境的时候我遇到了让我非常头疼的问题，那就是 pod install 执行时慢的要死。忍不了啊，搜索了一番之后找到了有效的方法，在此做一个Mark。下面我们就来看看是如何提高pod install 的安装速度的。 其实，pod 真正慢的原因不在于你执行的pod 命令而是github上面的代码库访问速度真的慢，翻墙也不行啊。那么真正的t解决办法是提高git 命令的速速。 我们开发者一般都会用代理工具，这里我用的是Shadowsocks代理，我的默认端口号是1086，如下图： 拿到上图中的端口号之后，我们执行一个命令：1git config --global http.https://github.com.proxy socks5://127.0.0.1:1086 这个命令中我设置了只是github上的代码库才走代理。当然我们也可以给git 设置全局代理：1git config --global http.proxy socks5://127.0.0.1:1086 但是第一个命令才是我们需要的。 执行完之后可以对比一下安装的速度：配置命令之前的速度： 配置命令之后的速速： 从图中可以看到，速度提高了许多倍啊！！ 最后提示一下，如果想去掉上面我们配置命令可以采用如下方法： 12去掉全局git代理git config --global --unset http.proxy 12去掉github代理git config --global --unset http.https://github.com.proxy]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS调试器LLDB]]></title>
    <url>%2F2019%2F10%2F03%2FiOS%E8%B0%83%E8%AF%95%E5%99%A8LLDB%2F</url>
    <content type="text"><![CDATA[我们平时开发中调试代码往往使用Log去打印一些变量比如： NSLog(@&quot;%@&quot;,name); 还有其他的Case，但是这些Case往往要重新编译，重新运行，然后等待是否是期待的结果。 但是也不一定要这么做。我们可以使用调试器，达到一些你意向不到的效果。 LLDBLLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时暂停它，你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展。(这里有一个关于调试器如何工作的总体的解释。) 你以前有可能已经使用过调试器，即使只是在 Xcode 的界面上加一些断点。但是通过一些小的技巧，你就可以做一些非常酷的事情。GDB to LLDB 参考是一个非常好的调试器可用命令的总览。你也可以安装 Chisel，它是一个开源的 LLDB 插件合辑，这会使调试变得更加有趣。 与此同时，让我们以在调试器中打印变量来开始我们的旅程吧。 基础这里有一个简单的小程序(如图1)，我把断点加在了第8行，程序会在这一行停止运行，并且控制台会被打开，允许我们和调试器交互。那么我们就来试一下吧。 图(1) help最简单的命令是help,它会列举出所有的命令。如果你忘记了一个命令是做什么的，或者想知道更多的话，你可以通help&lt;command&gt;来了解更多细节，例如help print或者help thread。如果你甚至忘记了help,你可以试试help help. print打印值很简单;只需要试试print命令: LLDB实际上会作前缀匹配,所以我们也可以使用prin,pri,或者干脆来个p;但是不可以使用pr,因为LLDB不能消除和process的歧义; 你可能还注意到了,结果中有个$0,实际上我们可以使用它来指向这个结果. 试试print $0 + 7,你会看到106.任何以美元开头的东西都存在于LLDB的命名空间.它们是为了帮助我们进行调试而存在的. expression如果想改变一个变量的值怎么办呢? 我们可以使用expression这个方便的命令. 这不仅会改变调试器中的值,实际上它改变了程序中的值.这时候继续执行程序,将会打印42 red balloons 神奇吧. 注意,我们从此时开始,将会使用p 和 e 来代替print和expession. 什么是print命令考虑一个有意思的表达式:p count = 18.如果我们运行这条命令，然后打印 count 的内容。我们将看到它的结果与 expression count = 18 一样。 和 expression 不同的是，print 命令不需要参数。比如 e -h +17 中，你很难区分到底是以 -h 为标识，仅仅执行 +17 呢，还是要计算 17 和 h 的差值。连字符号确实很让人困惑，你或许得不到自己想要的结果。 幸运的是，解决方案很简单。用 -- 来表征标识的结束，以及输入的开始。如果想要 -h 作为标识，就用 e -h -- +17，如果想计算它们的差值，就使用 e -- -h +17。因为一般来说不使用标识的情况比较多，所以 e -- 就有了一个简写的方式，那就是 print。 输入 help print，然后向下滚动，你会发现： 12&apos;print&apos; is an abbreviation for &apos;expression --&apos;. (print是 `expression --` 的缩写) 打印对象尝试输入 p objects 输出会有点啰嗦 1(NSString *) $7 = 0x0000000104da4040 @&quot;red balloons&quot; 如果我们尝试打印结构更复杂的对象，结果甚至会更糟 123(lldb) p @[ @&quot;foo&quot;, @&quot;bar&quot; ](NSArray *) $8 = 0x00007fdb9b71b3e0 @&quot;2 objects&quot; 实际上，我们想看的是对象的 description 方法的结果。我么需要使用 -O (字母 O，而不是数字 0) 标志告诉 expression 命令以 对象 (Object) 的方式来打印结果。 12345(lldb) e -O -- $8&lt;__NSArrayI 0x7fdb9b71b3e0&gt;(foo,bar) 幸运的是，e -o -- 有也有个别名，那就是 po (print object 的缩写)，我们可以使用它来进行简化： 123456789(lldb) po $8&lt;__NSArrayI 0x7fdb9b71b3e0&gt;(foo,bar)(lldb) po @&quot;lunar&quot;lunar(lldb) p @&quot;lunar&quot;(NSString *) $13 = 0x00007fdb9d0003b0 @&quot;lunar&quot; 打印变量可以给 print 指定不同的打印格式。它们都是以 print/ 或者简化的 p/ 格式书写。下面是一些例子： 默认的格式 12(lldb) p 1616 十六进制: 12(lldb) p/x 160x10 二进制 (t 代表 two)： 1234(lldb) p/t 160b00000000000000000000000000010000(lldb) p/t (char)160b00010000 你也可以使用 p/c 打印字符，或者 p/s 打印以空终止的字符串 (译者注：以 ‘\0’ 结尾的字符串)。这里是格式的完整清单。 变量现在你已经可以打印对象和简单类型,并且知道如何使用expression 命令在调试器中修改它们了. 现在我们使用一些变量来减少输入量.就像你们用C语言声明一个变量:int a = 0 ,也可以再LLDB中做同样的事情.不过为了能使用声明的变量,必须以$符号开头. 1234567891011(lldb) e int $a = 2(lldb) p $a * 1938(lldb) e NSArray *$array = @[ @&quot;Saturday&quot;, @&quot;Sunday&quot;, @&quot;Monday&quot; ](lldb) p [$array count]2(lldb) po [[$array objectAtIndex:0] uppercaseString]SATURDAY(lldb) p [[$array objectAtIndex:$a] characterAtIndex:0]error: no known method &apos;-characterAtIndex:&apos;; cast the message send to the method&apos;s return typeerror: 1 errors parsing expression 悲剧了，LLDB 无法确定涉及的类型 (译者注：返回的类型)。这种事情常常发生，给个说明就好了： 1234(lldb) p (char)[[$array objectAtIndex:$a] characterAtIndex:0]&apos;M&apos;(lldb) p/d (char)[[$array objectAtIndex:$a] characterAtIndex:0]77 变量使调试器变的容易使用得多，想不到吧？😉 流程控制当你通过 Xcode 的源码编辑器的侧边槽 (或者通过下面的方法) 插入一个断点，程序到达断点时会就会停止运行。 调试条上会出现四个你可以用来控制程序的执行流程的按钮。 从左到右，四个按钮分别是：continue，step over，step into，step out。 第一个，continue 按钮，会取消程序的暂停，允许程序正常执行 (要么一直执行下去，要么到达下一个断点)。在 LLDB 中，你可以使用 process continue 命令来达到同样的效果，它的别名为 continue，或者也可以缩写为 c。 第二个，step over 按钮，会以黑盒的方式执行一行代码。如果所在这行代码是一个函数调用，那么就不会跳进这个函数，而是会执行这个函数，然后继续。LLDB 则可以使用 thread step-over，next，或者 n 命令。 如果你确实想跳进一个函数调用来调试或者检查程序的执行情况，那就用第三个按钮，step in，或者在LLDB中使用 thread step in，step，或者 s 命令。注意，当前行不是函数调用时，next 和 step 效果是一样的。 大多数人知道 c，n 和 s，但是其实还有第四个按钮，step out。如果你曾经不小心跳进一个函数，但实际上你想跳过它，常见的反应是重复的运行 n 直到函数返回。其实这种情况，step out 按钮是你的救世主。它会继续执行到下一个返回语句 (直到一个堆栈帧结束) 然后再次停止。 例子考虑下面一段程序： 假如我们运行程序，让它停止在断点，然后执行下面一些列命令： 1234567p insp ifinishp iframe info 这里，frame info 会告诉你当前的行数和源码文件，以及其他一些信息；查看 help frame，help thread 和 help process 来获得更多信息。这一串命令的结果会是什么？看答案之前请先想一想。 12345678910111213(lldb) p i(int) $0 = 99(lldb) n2014-11-22 10:49:26.445 DebuggerDance[60182:4832768] 101 is odd!(lldb) s(lldb) p i(int) $2 = 110(lldb) finish2014-11-22 10:49:35.978 DebuggerDance[60182:4832768] 110 is even!(lldb) p i(int) $4 = 99(lldb) frame infoframe #0: 0x000000010a53bcd4 DebuggerDance`main + 68 at main.m:17 它始终在 17 行的原因是 finish 命令一直运行到 isEven() 函数的 return，然后立刻停止。注意即使它还在 17 行，其实这行已经被执行过了。 Thread Return调试时，还有一个很棒的函数可以用来控制程序流程：thread return 。它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后立刻执行返回命令，跳出当前栈帧。这意味这函数剩余的部分不会被执行。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是在函数的开头执行这个命令，是个非常好的隔离这个函数，伪造返回值的方式 。 让我们稍微修改一下上面代码段并运行： 123456p isthread return NOnp even0frame info 看答案前思考一下。下面是答案： 123456789(lldb) p i(int) $0 = 99(lldb) s(lldb) thread return NO(lldb) n(lldb) p even0(BOOL) $2 = NO(lldb) frame infoframe #0: 0x00000001009a5cc4 DebuggerDance`main + 52 at main.m:17 断点我们都把断点作为一个停止程序运行，检查当前状态，追踪 bug 的方式。但是如果我们改变和断点交互的方式，很多事情都变成可能。 断点允许控制程序什么时候停止，然后允许命令的运行。 想象把断点放在函数的开头，然后用 thread return 命令重写函数的行为，然后继续。想象一下让这个过程自动化，听起来不错，不是吗？ 管理断点Xcode 提供了一系列工具来创建和管理断点。我们会一个个看过来并介绍 LLDB 中等价的命令 (是的，你可以在调试器内部添加断点)。 在 Xcode 的左侧面板，有一组按钮。其中一个看起来像断点。点击它打开断点导航，这是一个可以快速管理所有断点的面板。 在这里你可以看到所有的断点 - 在 LLDB 中通过 breakpoint list (或者 br li) 命令也做同样的事儿。你也可以点击单个断点来开启或关闭 - 在 LLDB 中使用 breakpoint enable 和 breakpoint disable： 123456789101112131415161718(lldb) br liCurrent breakpoints:1: file = &apos;/Users/arig/Desktop/DebuggerDance/DebuggerDance/main.m&apos;, line = 16, locations = 1, resolved = 1, hit count = 1 1.1: where = DebuggerDance`main + 27 at main.m:16, address = 0x000000010a3f6cab, resolved, hit count = 1(lldb) br dis 11 breakpoints disabled.(lldb) br liCurrent breakpoints:1: file = &apos;/Users/arig/Desktop/DebuggerDance/DebuggerDance/main.m&apos;, line = 16, locations = 1 Options: disabled 1.1: where = DebuggerDance`main + 27 at main.m:16, address = 0x000000010a3f6cab, unresolved, hit count = 1(lldb) br del 11 breakpoints deleted; 0 breakpoint locations disabled.(lldb) br liNo breakpoints currently set. 创建断点在上面的例子中，我们通过在源码页面器的滚槽 16 上点击来创建断点。你可以通过把断点拖拽出滚槽，然后释放鼠标来删除断点 (消失时会有一个非常可爱的噗的一下的动画)。你也可以在断点导航页选择断点，然后按下删除键删除。 要在调试器中创建断点，可以使用 breakpoint set 命令。 12(lldb) breakpoint set -f main.m -l 16Breakpoint 1: where = DebuggerDance`main + 27 at main.m:16, address = 0x000000010a3f6cab 也可以使用缩写形式 br。虽然 b 是一个完全不同的命令 (_regexp-break 的缩写)，但恰好也可以实现和上面同样的效果。 12(lldb) b main.m:17Breakpoint 2: where = DebuggerDance`main + 52 at main.m:17, address = 0x000000010a3f6cc4 也可以在一个符号 (C 语言函数) 上创建断点，而完全不用指定哪一行 1234(lldb) b isEvenBreakpoint 3: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x000000010a3f6d00(lldb) br s -F isEvenBreakpoint 4: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x000000010a3f6d00 这些断点会准确的停止在函数的开始。Objective-C 的方法也完全可以： 12345678(lldb) breakpoint set -F &quot;-[NSArray objectAtIndex:]&quot;Breakpoint 5: where = CoreFoundation`-[NSArray objectAtIndex:], address = 0x000000010ac7a950(lldb) b -[NSArray objectAtIndex:]Breakpoint 6: where = CoreFoundation`-[NSArray objectAtIndex:], address = 0x000000010ac7a950(lldb) breakpoint set -F &quot;+[NSSet setWithObject:]&quot;Breakpoint 7: where = CoreFoundation`+[NSSet setWithObject:], address = 0x000000010abd3820(lldb) b +[NSSet setWithObject:]Breakpoint 8: where = CoreFoundation`+[NSSet setWithObject:], address = 0x000000010abd3820 如果想在 Xcode 的UI上创建符号断点，你可以点击断点栏左侧的 + 按钮。 然后选择第三个选项： 这时会出现一个弹出框，你可以在里面添加例如 -[NSArray objectAtIndex:] 这样的符号断点。这样每次调用这个函数的时候，程序都会停止，不管是你调用还是苹果调用。 如果你 Xcode 的 UI 上右击任意断点，然后选择 “Edit Breakpoint” 的话，会有一些非常诱人的选择。 这里，断点已经被修改为只有当 i 是 99 的时候才会停止。你也可以使用 “ignore” 选项来告诉断点最初的 n 次调用 (并且条件为真的时候) 的时候不要停止。 接下来介绍 ‘Add Action’ 按钮… 断点行为 (Action)上面的例子中，你或许想知道每一次到达断点的时候 i 的值。我们可以使用 p i 作为断点行为。这样每次到达断点的时候，都会自动运行这个命令。 你也可以添加多个行为，可以是调试器命令，shell 命令，也可以是更直接的打印： 可以看到它打印 i，然后大声念出那个句子，接着打印了自定义的表达式。 下面是在 LLDB 而不是 Xcode 的 UI 中做这些的时候，看起来的样子。 123456789101112131415(lldb) breakpoint set -F isEvenBreakpoint 1: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x00000001083b5d00(lldb) breakpoint modify -c &apos;i == 99&apos; 1(lldb) breakpoint command add 1Enter your debugger command(s). Type &apos;DONE&apos; to end.&gt; p i&gt; DONE(lldb) br li 11: name = &apos;isEven&apos;, locations = 1, resolved = 1, hit count = 0 Breakpoint commands: p iCondition: i == 99 1.1: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x00000001083b5d00, resolved, hit count = 0 接下来说说自动化。 赋值后继续运行看编辑断点弹出窗口的底部，你还会看到一个选项： “Automatically continue after evaluation actions.” 。它仅仅是一个选择框，但是却很强大。选中它，调试器会运行你所有的命令，然后继续运行。看起来就像没有执行任何断点一样 (除非断点太多，运行需要一段时间，拖慢了你的程序)。 这个选项框的效果和让最后断点的最后一个行为是 continue 一样。选框只是让这个操作变得更简单。调试器的输出是： 123456789101112(lldb) breakpoint set -F isEvenBreakpoint 1: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x00000001083b5d00(lldb) breakpoint command add 1Enter your debugger command(s). Type &apos;DONE&apos; to end.&gt; continue&gt; DONE(lldb) br li 11: name = &apos;isEven&apos;, locations = 1, resolved = 1, hit count = 0 Breakpoint commands: continue 1.1: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x00000001083b5d00, resolved, hit count = 0 执行断点后自动继续运行，允许你完全通过断点来修改程序！你可以在某一行停止，运行一个 expression 命令来改变变量，然后继续运行。 例子想想所谓的”打印调试”技术吧，不要这么做： 1NSLog(@&quot;%@&quot;, whatIsInsideThisThing); 而是用个打印变量的断点替换 log 语句，然后继续运行。 也不要： 1234567int calculateTheTrickyValue &#123; return 9; /* Figure this out later. ...&#125; 而是加一个使用 thread return 9 命令的断点，然后让它继续运行。 符号断点加上 action 真的很强大。你也可以在你朋友的 Xcode 工程上添加一些断点，并且加上大声朗读某些东西的 action。看看他们要花多久才能弄明白发生了什么。😄 完全在调试器内运行在开始舞蹈之前，还有一件事要看一看。实际上你可以在调试器中执行任何 C/Objective-C/C++/Swift 的命令。唯一的缺点就是不能创建新函数… 这意味着不能创建新的类，block，函数，有虚拟函数的 C++ 类等等。除此之外，它都可以做。 我们可以申请分配一些字节： 123456(lldb) e char *$str = (char *)malloc(8)(lldb) e (void)strcpy($str, &quot;munkeys&quot;)(lldb) e $str[1] = &apos;o&apos;(char) $0 = &apos;o&apos;(lldb) p $str(char *) $str = 0x00007fd04a900040 &quot;monkeys&quot; 我们可以查看内存 (使用 x 命令)，来看看新数组中的四个字节： 12(lldb) x/4c $str0x7fd04a900040: monk 我们也可以去掉 3 个字节 (x 命令需要斜引号，因为它只有一个内存地址的参数，而不是表达式；使用 help x 来获得更多信息)： 12(lldb) x/1w `$str + 3`0x7fd04a900043: keys 做完了之后，一定不要忘了释放内存，这样才不会内存泄露。(哈，虽然这是调试器用到的内存)： 1(lldb) e (void)free($str) 让我们起舞现在我们已经知道基本的步调了，是时候开始跳舞并玩一些疯狂的事情了。我曾经写过一篇 NSArray 深度探究的博客。这篇博客用了很多 NSLog 语句，但实际上我的所有探索都是在调试器中完成的。看看你能不能弄明白怎么做的，这会是一个有意思的练习。 不用断点调试程序运行时，Xcode 的调试条上会出现暂停按钮，而不是继续按钮： 点击按钮会暂停 app (这会运行 process interrupt 命令，因为 LLDB 总是在背后运行)。这会让你可以访问调试器，但看起来可以做的事情不多，因为在当前作用域没有变量，也没有特定的代码让你看。 这就是有意思的地方。如果你正在运行 iOS app，你可以试试这个： (因为全局变量是可访问的) 123 (lldb) po [[[UIApplication sharedApplication] keyWindow] recursiveDescription]&lt;UIWindow: 0x7f82b1fa8140; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x7f82b1fa92d0&gt;; layer = &lt;UIWindowLayer: 0x7f82b1fa8400&gt;&gt; | &lt;UIView: 0x7f82b1d01fd0; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x7f82b1e2e0a0&gt;&gt; 你可以看到整个层次。Chisel 中 pviews 就是这么实现的。 更新UI有了上面的输出，我们可以获取这个 view： 1(lldb) e id $myView = (id)0x7f82b1d01fd0 然后在调试器中改变它的背景色： 1(lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]] 但是只有程序继续运行之后才会看到界面的变化。因为改变的内容必须被发送到渲染服务中，然后显示才会被更新。 渲染服务实际上是一个另外的进程 (被称作 backboardd)。这就是说即使我们正在调试的内容所在的进程被打断了，backboardd 也还是继续运行着的。 这意味着你可以运行下面的命令，而不用继续运行程序： 1(lldb) e (void)[CATransaction flush] 即使你仍然在调试器中，UI 也会在模拟器或者真机上实时更新。Chisel 为此提供了一个别名叫做 caflush，这个命令被用来实现其他的快捷命令，例如 hide，show 以及其他很多命令。所有 Chisel 的命令都有文档，所以安装后随意运行 help show 来看更多信息。 Push 一个 View Controller想象一个以 UINavigationController 为 root ViewController 的应用。你可以通过下面的命令，轻松地获取它： 1(lldb) e id $nvc = [[[UIApplication sharedApplication] keyWindow] rootViewController] 然后 push 一个 child view controller: 1234(lldb) e id $vc = [UIViewController new](lldb) e (void)[[$vc view] setBackgroundColor:[UIColor yellowColor]](lldb) e (void)[$vc setTitle:@&quot;Yay!&quot;](lldb) e (void)[$nvc pushViewContoller:$vc animated:YES] 最后运行下面的命令： 1(lldb) caflush // e (void)[CATransaction flush] navigation Controller 就会立刻就被 push 到你眼前。 查找按钮的 target想象你在调试器中有一个 $myButton 的变量，可以是创建出来的，也可以是从 UI 上抓取出来的，或者是你停止在断点时的一个局部变量。你想知道，按钮按下的时候谁会接收到按钮发出的 action。非常简单： 12345678(lldb) po [$myButton allTargets]&#123;( &lt;MagicEventListener: 0x7fb58bd2e240&gt;)&#125;(lldb) po [$myButton actionsForTarget:(id)0x7fb58bd2e240 forControlEvent:0]&lt;__NSArrayM 0x7fb58bd2aa40&gt;(_handleTap:) 现在你或许想在它发生的时候加一个断点。在 -[MagicEventListener _handleTap:] 设置一个符号断点就可以了，在 Xcode 和 LLDB 中都可以，然后你就可以点击按钮并停在你所希望的地方了。 观察实例变量的变化假设你有一个 UIView，不知道为什么它的 _layer 实例变量被重写了 (糟糕)。因为有可能并不涉及到方法，我们不能使用符号断点。相反的，我们想监视什么时候这个地址被写入。 首先，我们需要找到 _layer 这个变量在对象上的相对位置： 12(lldb) p (ptrdiff_t)ivar_getOffset((struct Ivar *)class_getInstanceVariable([MyView class], &quot;_layer&quot;))(ptrdiff_t) $0 = 8 现在我们知道 ($myView + 8) 是被写入的内存地址： 123(lldb) watchpoint set expression -- (int *)$myView + 8Watchpoint created: Watchpoint 3: addr = 0x7fa554231340 size = 8 state = enabled type = w new value: 0x0000000000000000 这被以 wivar $myView _layer 加入到 Chisel 中。 非重写方法的符号断点假设你想知道 -[MyViewController viewDidAppear:] 什么时候被调用。如果这个方法并没有在MyViewController 中实现，而是在其父类中实现的，该怎么办呢？试着设置一个断点，会出现以下结果： 123(lldb) b -[MyViewController viewDidAppear:]Breakpoint 1: no locations (pending).WARNING: Unable to resolve breakpoint to any actual locations. 因为 LLDB 会查找一个符号，但是实际在这个类上却找不到，所以断点也永远不会触发。你需要做的是为断点设置一个条件 [self isKindOfClass:[MyViewController class]]，然后把断点放在 UIViewController 上。正常情况下这样设置一个条件可以正常工作。但是这里不会，因为我们没有父类的实现。 viewDidAppear: 是苹果实现的方法，因此没有它的符号；在方法内没有 self 。如果想在符号断点上使用 self，你必须知道它在哪里 (它可能在寄存器上，也可能在栈上；在 x86 上，你可以在 $esp+4 找到它)。但是这是很痛苦的，因为现在你必须至少知道四种体系结构 (x86，x86-64，armv7，armv64)。想象你需要花多少时间去学习命令集以及它们每一个的调用约定，然后正确的写一个在你的超类上设置断点并且条件正确的命令。幸运的是，这个在 Chisel 被解决了。这被成为 bmessage： 123(lldb) bmessage -[MyViewController viewDidAppear:]Setting a breakpoint at -[UIViewController viewDidAppear:] with condition (void*)object_getClass((id)$rdi) == 0x000000010e2f4d28Breakpoint 1: where = UIKit`-[UIViewController viewDidAppear:], address = 0x000000010e11533c LLDB 和 PythonLLDB 有内建的，完整的 Python 支持。在LLDB中输入 script，会打开一个 Python REPL。你也可以输入一行 python 语句作为 script 命令 的参数，这可以运行 python 语句而不进入REPL： 12(lldb) script import os(lldb) script os.system(&quot;open http://www.objc.io/&quot;) 这样就允许你创造各种酷的命令。把下面的语句放到文件 ~/myCommands.py 中： 12def caflushCommand(debugger, command, result, internal_dict): debugger.HandleCommand(&quot;e (void)[CATransaction flush]&quot;) 然后再 LLDB 中运行： 1command script import ~/myCommands.py 或者把这行命令放在 /.lldbinit 里，这样每次进入 LLDB 时都会自动运行。Chisel 其实就是一个 Python 脚本的集合，这些脚本拼接 (命令) 字符串 ，然后让 LLDB 执行。很简单，不是吗？ 紧握调试器这一武器LLDB 可以做的事情很多。大多数人习惯于使用 p，po，n，s 和 c，但实际上除此之外，LLDB 可以做的还有很多。掌握所有的命令 (实际上并不是很多)，会让你在揭示代码运行时的运行状态，寻找 bug，强制执行特定的运行路径时获得更大的能力。你甚至可以构建简单的交互原型 - 比如要是现在以 modal 方式弹出一个 View Controller 会怎么样？使用调试器，一试便知。 这篇文章是为了想你展示 LLDB 的强大之处，并且鼓励你多去探索在控制台输入命令。 打开 LLDB，输入 help，看一看列举的命令。你尝试过多少？用了多少？ 但愿 NSLog 看起来不再那么吸引你去用，每次编辑再运行并不有趣而且耗时。 调试愉快！ 声明:本文为转载]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage (5.0.6) 图片缓存读写原理]]></title>
    <url>%2F2019%2F08%2F04%2FSDWebImage%20(5.0.6)%20%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[SDWebImage (5.0.6)图片加载奇淫巧技 这篇文章介绍了SDWebImage加载图片的流程是怎样的，本文我们一起讨论一下，SDWebImage框架的缓存机制是怎么样的。我们先来看加载过程中，SDWebImage是如何从缓存中读取我们所需的图片的，我们先找到读取缓存的入口：12// Start the entry to load image from cache [self callCacheProcessForOperation:operation url:url options:options context:context progress:progressBlock completed:completedBlock]; 这个方法就是开始从缓存中读取，方法内部实现如下：123456789101112131415161718192021222324252627// Query cache process- (void)callCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operationurl:(nonnull NSURL *)urloptions:(SDWebImageOptions)optionscontext:(nullable SDWebImageContext *)contextprogress:(nullable SDImageLoaderProgressBlock)progressBlockcompleted:(nullable SDInternalCompletionBlock)completedBlock &#123; // Check whether we should query cache BOOL shouldQueryCache = (options &amp; SDWebImageFromLoaderOnly) == 0; if (shouldQueryCache) &#123; id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter]; NSString *key = [self cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter]; @weakify(operation); operation.cacheOperation = [self.imageCache queryImageForKey:key options:options context:context completion:^(UIImage * _Nullable cachedImage, NSData * _Nullable cachedData, SDImageCacheType cacheType) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; [self safelyRemoveOperationFromRunning:operation]; return; &#125; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock]; &#125;]; &#125; else &#123; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:nil cachedData:nil cacheType:SDImageCacheTypeNone progress:progressBlock completed:completedBlock]; &#125;&#125; 从上面的源码可以看出，首先会判断一下是否需要从缓存中读取，如果不需要就直接去下载了。如果需要的话，就会使用self.imageCache实例去查询缓存，核心代码：123456789[self.imageCache queryImageForKey:key options:options context:context completion:^(UIImage * _Nullable cachedImage, NSData * _Nullable cachedData, SDImageCacheType cacheType) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; [self safelyRemoveOperationFromRunning:operation]; return; &#125; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock];&#125;]; 我们可以看到，查询结果回调之后，又调用了下载方法，这时因为缓存查询的结果也在下载方法里面处理了。我们接着看查询缓存的方法：queryImageForKey: 看下它的内部实现:1234567891011- (id&lt;SDWebImageOperation&gt;)queryImageForKey:(NSString *)key options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context completion:(nullable SDImageCacheQueryCompletionBlock)completionBlock &#123; SDImageCacheOptions cacheOptions = 0; if (options &amp; SDWebImageQueryMemoryData) cacheOptions |= SDImageCacheQueryMemoryData; if (options &amp; SDWebImageQueryMemoryDataSync) cacheOptions |= SDImageCacheQueryMemoryDataSync; if (options &amp; SDWebImageQueryDiskDataSync) cacheOptions |= SDImageCacheQueryDiskDataSync; if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages; if (options &amp; SDWebImageAvoidDecodeImage) cacheOptions |= SDImageCacheAvoidDecodeImage; if (options &amp; SDWebImageDecodeFirstFrameOnly) cacheOptions |= SDImageCacheDecodeFirstFrameOnly; if (options &amp; SDWebImagePreloadAllFrames) cacheOptions |= SDImageCachePreloadAllFrames; return [self queryCacheOperationForKey:key options:cacheOptions context:context done:completionBlock];&#125; 这个方法里面做了一堆跟缓存相关的条件判断，然后调用了queryCacheOperationForKey:这个方法，正式进入缓存查询。我们接着看这个方法的源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options context:(nullable SDWebImageContext *)context done:(nullable SDImageCacheQueryCompletionBlock)doneBlock &#123; if (!key) &#123; if (doneBlock) &#123; doneBlock(nil, nil, SDImageCacheTypeNone); &#125; return nil; &#125; id&lt;SDImageTransformer&gt; transformer = context[SDWebImageContextImageTransformer]; if (transformer) &#123; // grab the transformed disk image if transformer provided NSString *transformerKey = [transformer transformerKey]; key = SDTransformedKeyForKey(key, transformerKey); &#125; // First check the in-memory cache... UIImage *image = [self imageFromMemoryCacheForKey:key]; if ((options &amp; SDImageCacheDecodeFirstFrameOnly) &amp;&amp; image.sd_isAnimated) &#123; #if SD_MAC image = [[NSImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:kCGImagePropertyOrientationUp]; #else image = [[UIImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:image.imageOrientation]; #endif &#125; BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryMemoryData)); if (shouldQueryMemoryOnly) &#123; if (doneBlock) &#123; doneBlock(image, nil, SDImageCacheTypeMemory); &#125; return nil; &#125; // Second check the disk cache... NSOperation *operation = [NSOperation new]; // Check whether we need to synchronously query disk // 1. in-memory cache hit &amp; memoryDataSync // 2. in-memory cache miss &amp; diskDataSync BOOL shouldQueryDiskSync = ((image &amp;&amp; options &amp; SDImageCacheQueryMemoryDataSync) || (!image &amp;&amp; options &amp; SDImageCacheQueryDiskDataSync)); void(^queryDiskBlock)(void) = ^&#123; if (operation.isCancelled) &#123; // do not call the completion if cancelled return; &#125; @autoreleasepool &#123; NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage; SDImageCacheType cacheType = SDImageCacheTypeNone; if (image) &#123; // the image is from in-memory cache, but need image data diskImage = image; cacheType = SDImageCacheTypeMemory; &#125; else if (diskData) &#123; cacheType = SDImageCacheTypeDisk; // decode image data only if in-memory cache missed diskImage = [self diskImageForKey:key data:diskData options:options context:context]; if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = diskImage.sd_memoryCost; [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; &#125; if (doneBlock) &#123; if (shouldQueryDiskSync) &#123; doneBlock(diskImage, diskData, cacheType); &#125; else &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, cacheType); &#125;); &#125; &#125; &#125; &#125;; // Query in ioQueue to keep IO-safe if (shouldQueryDiskSync) &#123; dispatch_sync(self.ioQueue, queryDiskBlock); &#125; else &#123; dispatch_async(self.ioQueue, queryDiskBlock); &#125; return operation;&#125; 接下来我们解析一下这个方法：首先做了参数合法性判断，不满足条件直接返回空。紧接着就是从内存缓存中查询我们需要的图片：12// First check the in-memory cache...UIImage *image = [self imageFromMemoryCacheForKey:key]; 这个方法比较简单，就是直接从memCache中按照key来读取： [self.memCache objectForKey:key];接下来判断图片是否是动图，做相应的处理。然后，判断是否是只需在内存中查找，如果是的话直接返回刚才查到的图片，并结束方法调用。如果不是的话，就去硬盘中查找。1NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; 我们先把这个流程看完再来看究竟是如何从磁盘中读取Data的。接下来通过一系列条件得出是否需要同步查询缓存：12BOOL shouldQueryDiskSync = ((image &amp;&amp; options &amp; SDImageCacheQueryMemoryDataSync) ||(!image &amp;&amp; options &amp; SDImageCacheQueryDiskDataSync)); 然后生命一个磁盘查询的block: queryDiskBlock开始查询。接下来判断是否从内存中读取到了图片，如果有的话，不做其他处理，最后回调的时候把diskData一起回调出去就可以了。如果没有从内存中读取到图片，则就要看diskData是否为空，如果不为空，就对diskData进行解码处理，得到我们需要的diskImage。12// decode image data only if in-memory cache misseddiskImage = [self diskImageForKey:key data:diskData options:options context:context]; 然后把得到的diskImage放到内存缓存中一份。1234if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = diskImage.sd_memoryCost; [self.memCache setObject:diskImage forKey:key cost:cost];&#125; 到这里，从内存以及磁盘中读取缓存的流程完毕，接下来就是把我们读取出来的图片数据返回给调用方了。123456789if (doneBlock) &#123; if (shouldQueryDiskSync) &#123; doneBlock(diskImage, diskData, cacheType); &#125; else &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, cacheType); &#125;); &#125;&#125; 最后就是根据是否需要同步查询来调用queryDiskBlock了。这就是图片缓存查询的流程。接下来，我们回头看一下磁盘缓存查询究竟是如何实现的。1NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; 我们看一下这个方法的内部实现：1234567891011121314151617181920- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123; if (!key) &#123; return nil; &#125; NSData *data = [self.diskCache dataForKey:key]; if (data) &#123; return data; &#125; // Addtional cache path for custom pre-load cache if (self.additionalCachePathBlock) &#123; NSString *filePath = self.additionalCachePathBlock(key); if (filePath) &#123; data = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil]; &#125; &#125; return data;&#125; 首先是key参数判断，其次从diskCache中通过key来读取，如果磁盘缓存，内存中已经读取过的话，直接返回。否则的话，就会通过key得出磁盘缓存的路径，然后读取出来，返回给调用方。 接下来，我们一起看一下，从Server端下载完图片后，SDWebImage是如何处理的他两级（内存缓存、磁盘缓存）缓存的。同样的我们先找到保存缓存的入口方法：1[self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock]; 这个方法的调用时机，是在从网络下载完图片的回调中。这个方法的内部实现中有一句很重要的代码，就是我们存储缓存的代码：1[self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key cacheType:storeCacheType completion:nil]; 接下来我们来看一下，这个方法的内部实现：1234567891011121314151617181920212223242526- (void)storeImage:(UIImage *)image imageData:(NSData *)imageData forKey:(nullable NSString *)key cacheType:(SDImageCacheType)cacheType completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;switch (cacheType) &#123; case SDImageCacheTypeNone: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:NO toDisk:NO completion:completionBlock]; &#125; break; case SDImageCacheTypeMemory: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:YES toDisk:NO completion:completionBlock]; &#125; break; case SDImageCacheTypeDisk: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:NO toDisk:YES completion:completionBlock]; &#125; break; case SDImageCacheTypeAll: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:YES toDisk:YES completion:completionBlock]; &#125; break; default: &#123; if (completionBlock) &#123; completionBlock(); &#125; &#125; break; &#125;&#125; 内部实现其实比较简单，就是根据缓存类型做相应的存储。这一句才是重点：1[self storeImage:image imageData:imageData forKey:key toMemory:YES toDisk:YES completion:completionBlock]; 我们接着往下面看：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (void)storeImage:(nullable UIImage *)imageimageData:(nullable NSData *)imageDataforKey:(nullable NSString *)keytoMemory:(BOOL)toMemorytoDisk:(BOOL)toDiskcompletion:(nullable SDWebImageNoParamsBlock)completionBlock &#123; if (!image || !key) &#123; if (completionBlock) &#123; completionBlock(); &#125; return; &#125; // if memory cache is enabled if (toMemory &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = image.sd_memoryCost; [self.memCache setObject:image forKey:key cost:cost]; &#125; if (toDisk) &#123; dispatch_async(self.ioQueue, ^&#123; @autoreleasepool &#123; NSData *data = imageData; if (!data &amp;&amp; image) &#123; // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format SDImageFormat format; if ([SDImageCoderHelper CGImageContainsAlpha:image.CGImage]) &#123; format = SDImageFormatPNG; &#125; else &#123; format = SDImageFormatJPEG; &#125; data = [[SDImageCodersManager sharedManager] encodedDataWithImage:image format:format options:nil]; &#125; [self _storeImageDataToDisk:data forKey:key]; &#125; if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; &#125;); &#125; else &#123; if (completionBlock) &#123; completionBlock(); &#125; &#125;&#125; 接着我们分心一下存储缓存的最关键的方法，没错，就是上面的这段代码。首先，对参数进行合法性判断，如果不合法，直接返回。否则继续向下执行:第一步：判断是否允许内存缓存，如果允许就把下载好的图片存储在内存中一份。第二步：判断是否允许存储到磁盘，如果允许就进入磁盘存储逻辑：这里的存储任务是提交到了一个异步的串行队列中。任务的具体处理逻辑是：如果imageData 不存在，但是image 有值，则对image进行归档，得到一份data,这也是我们要写入到磁盘的data。最后，调用_storeImageDataToDisk:方法，将二进制图片数据写入到磁盘。第三步：将结果回调出去。 我们看一下_storeImageDataToDisk:方法的内部实现：12345678// Make sure to call form io queue by caller- (void)_storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123; if (!imageData || !key) &#123; return; &#125; [self.diskCache setData:imageData forKey:key];&#125; 比较简单，就是通过diskCache 实例来写缓存。接着我们进入diskCache类里面看下是如何写入的。我们看下SDDiskCache里面的setData: forKey:方法实现：1234567891011121314151617181920- (void)setData:(NSData *)data forKey:(NSString *)key &#123; NSParameterAssert(data); NSParameterAssert(key); if (![self.fileManager fileExistsAtPath:self.diskCachePath]) &#123; [self.fileManager createDirectoryAtPath:self.diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL]; &#125; // get cache Path for image key NSString *cachePathForKey = [self cachePathForKey:key]; // transform to NSUrl NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey]; [data writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil]; // disable iCloud backup if (self.config.shouldDisableiCloud) &#123; // ignore iCloud backup resource value error [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil]; &#125;&#125; 其实这个也很简单，就是简单的文件写入。 到这里，SDWebImage缓存的读写机制就介绍完了，欢迎大家勘误，SDWebImage这个库比较强大，里面还有很多细节，文中都没有提到，这里只是做了主流程的介绍，读者要是想深入的理解，还得是去阅读源码，建议的阅读的时候，和本文一起读，有助于理解源码。下一篇文章，会介绍SDWebImage是如何对图片进行编码解码的，欢迎大家阅读。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>图片缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage (5.0.6) 图片加载奇淫巧技]]></title>
    <url>%2F2019%2F07%2F29%2FSDWebImage%20(5.0.6)%20%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80%2F</url>
    <content type="text"><![CDATA[最近在研究图片缓存框架，所以SDWebImage一定是我研究的不二选择，下面就简单讲述一下SDWebImage是如何加载图片的，以及加载过程中涉及到的一些骚操作。 这里先强调一点SDWebImage加载图片过程中的两个骚操作：a. 如何避免同一时间多个请求，请求同一张图片下载多次问题。b. 如何解决TableViewCell 复用时导致的图片展示错乱问题。下文中会对这两个问题给出答案，好了不扯淡了，进入正题。 当我们使用SDWebImage加载图片时需要调用如下方法：123- (void)sd_setImageWithURL:(nullable NSURL *)url &#123; [self sd_setImageWithURL:url placeholderImage:nil options:0 progress:nil completed:nil];&#125; 之后进行一系列的传递会传递到最深层的方法：1234567891011121314- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock &#123; [self sd_internalSetImageWithURL:url placeholderImage:placeholder options:options context:context setImageBlock:nil progress:progressBlock completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, cacheType, imageURL); &#125; &#125;];&#125; 可以看到，这个方法里面调用了UIView+Webcache分类里面的一个方法：12345678- (void)sd_internalSetImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context setImageBlock:(nullable SDSetImageBlock)setImageBlock progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; ...... &#125; 这个方法就是我们加载图片的正式入口方法。下面我们看一下这个方法里面都主要做了什么。第一步，根据validOperationKey 取消掉正在执行的操作operation如下调用：123456NSString *validOperationKey = context[SDWebImageContextSetImageOperationKey];if (!validOperationKey) &#123; validOperationKey = NSStringFromClass([self class]);&#125;self.sd_latestOperationKey = validOperationKey;[self sd_cancelImageLoadOperationWithKey:validOperationKey]; sd_cancelImageLoadOperationWithKey: 方法的内部实现会查询到已经存在的同名任务，并且会取消掉这个任务，并在当前view的operationDictionary 容器中移除掉。源码如下：12345678910111213141516171819- (void)sd_cancelImageLoadOperationWithKey:(nullable NSString *)key &#123;if (key) &#123; // Cancel in progress downloader from queue SDOperationsDictionary *operationDictionary = [self sd_operationDictionary]; id&lt;SDWebImageOperation&gt; operation; @synchronized (self) &#123; operation = [operationDictionary objectForKey:key]; &#125; if (operation) &#123; if ([operation conformsToProtocol:@protocol(SDWebImageOperation)]) &#123; [operation cancel]; &#125; @synchronized (self) &#123; [operationDictionary removeObjectForKey:key]; &#125; &#125; &#125;&#125; 这里需要说明一下：[self sd_operationDictionary]这个调用，这个方法的实现是给当前View通过关联对象的技术关联了一个NSMapTable对象，用来存储请求链接接对应的请求操作类型如NSMapTable&lt;NSString *, id&gt;。源码如下：1234567891011- (SDOperationsDictionary *)sd_operationDictionary &#123; @synchronized(self) &#123; SDOperationsDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey); if (operations) &#123; return operations; &#125; operations = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC); return operations; &#125;&#125; 绕了这么大一圈，你可能会问，为什么一上来要调用sd_cancelImageLoadOperationWithKey:这个方法？通过上面的源码分析SDWebImage这样设计是为了解决TableViewCell复用时，如果被复用的Cell的ImageView请求的图片没有回调时展示图片错乱的问题。原理就是如果被复用的Cell的ImageView之前请求的图片还没有回调，而此时需要请求新的图片，那么就取消掉之前的请求operation,并从operationDictionary中移除掉。然后去加载需要加载的新图片。如果说，之前的图片请求在这之后回调回来的话，会判断之前请求的operation是否存在，以及operation的isCancel属性，如果不存在或者isCancel=Yes的话，就不会回调到UI界面。也就是如下代码逻辑：12345678@weakify(operation);operation.loaderOperation = [self.imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data &#125; 说了这么多，相信应该清楚为什么要调用sd_cancelImageLoadOperationWithKey:方法了，我们接着回到sd_internalSetImageWithURL:方法中，cancel之后就会清掉当前imageView上次下载的图片：12345if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123; [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:SDImageCacheTypeNone imageURL:url]; &#125;);&#125; 这里可以解释，复用的时候，已经展示过图片的imageView为什么在被复用的时候没有展示之前存在的图片而是展示placeholer或者不展示的原因。接下来，就是判断我们传入的url是否合法，以及设置UIImageView的加载指示器，还有加载进度block，此处不做详细说明了。我们着重看加载图片的方法：123id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options context:context progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; ......&#125; 这里当前view利用前面生成的manager 去加载我们需要的图片，并把获取的结果回调给了上一级调用方。从上面的代码可以看到，获取图片的同时返回了一个operation，这个operation就是标识获取当前url图片的一个操作。之后会把这个operation放在当前view的operationDictionary中：1[self sd_setImageLoadOperation:operation forKey:validOperationKey]; sd_setImageLoadOperation：内部实现如下:1234567891011- (void)sd_setImageLoadOperation:(nullable id&lt;SDWebImageOperation&gt;)operation forKey:(nullable NSString *)key &#123; if (key) &#123; [self sd_cancelImageLoadOperationWithKey:key]; if (operation) &#123; SDOperationsDictionary *operationDictionary = [self sd_operationDictionary]; @synchronized (self) &#123; [operationDictionary setObject:operation forKey:key]; &#125; &#125; &#125;&#125; 这也是程序一开始时，能够取消掉同名operation的原因。就是同一个view发送一个图片请求就会记录在operationDictionary中来标识有请求正在执行。我们接着看loadImageWithURL:方法内部实现：首先，判断url是否合法，然后生成一个请求图片的operation，这个和我们刚才讲到的operation在内存中是同一个，因为是从该方法中返回出去的。其次，将这个operation添加到正在运行的操作容器中：123SD_LOCK(self.runningOperationsLock);[self.runningOperations addObject:operation];SD_UNLOCK(self.runningOperationsLock); 之后进入重点，那就是开始从缓存中读取图片：12// Start the entry to load image from cache[self callCacheProcessForOperation:operation url:url options:options context:context progress:progressBlock completed:completedBlock]; 同样的，将我们刚才讲到的operation传入到这个方法中。我们看一下这个方法中做了什么：123456789101112131415161718192021222324252627// Query cache process- (void)callCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation url:(nonnull NSURL *)url options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; // Check whether we should query cache BOOL shouldQueryCache = (options &amp; SDWebImageFromLoaderOnly) == 0; if (shouldQueryCache) &#123; id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter]; NSString *key = [self cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter]; @weakify(operation); operation.cacheOperation = [self.imageCache queryImageForKey:key options:options context:context completion:^(UIImage * _Nullable cachedImage, NSData * _Nullable cachedData, SDImageCacheType cacheType) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; [self safelyRemoveOperationFromRunning:operation]; return; &#125; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock]; &#125;]; &#125; else &#123; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:nil cachedData:nil cacheType:SDImageCacheTypeNone progress:progressBlock completed:completedBlock]; &#125;&#125; 从上面的源码可以看出，首先判断是否需要从缓存中读取图片，如果需要，就处理url,处理后得到我们读取缓存的key。然后，开始从缓存中读取图片，回调之后判断当前operation是否还存在，以及operation是否被取消，如果取消的话就从runningOperations中移除当前operation并返回，什么也不做。否则，调用下载处理程序：callDownloadProcessForOperation：并把我们读取出来的缓存数据传入该方法。接下来我们看看这个方法的内部实现：首先判断是否需要下载图片，如果不需要就判断缓存数据如果缓存有值就直接返回给调用方，如果需要就先看一下之前读取的缓存数据是否有值，如果有值，就直接返回给调用方。如果没有的话，就使用imageLoader下载图片：1234567891011121314151617181920212223242526272829303132333435363738// `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle@weakify(operation);operation.loaderOperation = [self.imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data &#125; else if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached &amp;&amp; [error.domain isEqualToString:SDWebImageErrorDomain] &amp;&amp; error.code == SDWebImageErrorCacheNotModified) &#123; // Image refresh hit the NSURLCache cache, do not call the completion block &#125; else if (error) &#123; [self callCompletionBlockForOperation:operation completion:completedBlock error:error url:url]; BOOL shouldBlockFailedURL = [self shouldBlockFailedURLWithURL:url error:error]; if (shouldBlockFailedURL) &#123; SD_LOCK(self.failedURLsLock); [self.failedURLs addObject:url]; SD_UNLOCK(self.failedURLsLock); &#125; &#125; else &#123; if ((options &amp; SDWebImageRetryFailed)) &#123; SD_LOCK(self.failedURLsLock); [self.failedURLs removeObject:url]; SD_UNLOCK(self.failedURLsLock); &#125; [self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock]; &#125; if (finished) &#123; [self safelyRemoveOperationFromRunning:operation]; &#125;&#125;]; 从上面的源码中可以看出请求图片的回调回来后：1.如果operation不存在或者被取消，什么也不处理2.如果有error则直接回调错误信息，并把当前url加入到filedURLs中。3.如果一切正常，则把错误请求从filedURLs中移除，并把下载好的图片数据传递到缓存处理程序。4.最后，如果finished==YES，则把当前operation从runningOperations中移除。 接下来我们看一下这个方法的内部实现：首先处理一些下载器选项，然后调用下载图片方法：1return [self downloadImageWithURL:url options:downloaderOptions context:context progress:progressBlock completed:completedBlock]; 接着看上面这个方法的内部实现：首先判断url是否合法，如果合法，从下载器的URLOperations属性中读取该url对应的operation，如果operation不存在，或者已经取消或者已经完成，则根据url重新生成一个operation,同时记录该operation到URLOperations中，并把该operation添加到下载队列中去：1234self.URLOperations[url] = operation;// Add operation to operation queue only after all configuration done according to Apple&apos;s doc.// `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.[self.downloadQueue addOperation:operation]; 如果存在operation，但是operation没有正在执行，则根据条件调整operation的请求优先级。如果有正在执行的operation，不创建新的请求operation，而是给当前operation添加回调对象progressBlock 和 completedBlock。 1id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; 看下这个方法的内部实现：12345678910- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlockcompleted:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123; SDCallbacksDictionary *callbacks = [NSMutableDictionary new]; if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy]; if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy]; SD_LOCK(self.callbacksLock); [self.callbackBlocks addObject:callbacks]; SD_UNLOCK(self.callbacksLock); return callbacks;&#125; 从中可以看出一个ImageDownloaderOperation可以有多个回调block。那么问题来了，SDWebImage为什么会这么设计呢？答案是为了解决在同一时间，多个请求同时下载一张图片的时候，对该图片请求只下载一次。也就是请求只发送一次，而请求有结果的时候根据存储的多个返回block 依次返回给调用方。这方法是不是很机智。这一点也可从请求结果的代码中得到验证：1234567891011- (void)callCompletionBlocksWithImage:(nullable UIImage *)imageimageData:(nullable NSData *)imageData error:(nullable NSError *)error finished:(BOOL)finished &#123; NSArray&lt;id&gt; *completionBlocks = [self callbacksForKey:kCompletedCallbackKey]; dispatch_main_async_safe(^&#123; for (SDWebImageDownloaderCompletedBlock completedBlock in completionBlocks) &#123; completedBlock(image, imageData, error, finished); &#125; &#125;);&#125; 从上面的代码中可以看到，方法内部是遍历了所有需要完成回调的completedBlock,然后回调出去。 到这里，SDWebImage加载图片的主要流程就已经基本讲完，本文中着重讲述了下载流程，并没有对缓存部分做详细说明，后面会抽时间完善。欢迎勘误。PS:建议在阅读本文时和源码一起阅读。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>图片缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小试工厂模式]]></title>
    <url>%2F2019%2F05%2F03%2F%E5%B0%8F%E8%AF%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在开发过程中，很多人钟情于if/else连环写法，举个简单的例子，一个页面有N个菜单，点击的时候通过枚举类型来进行业务逻辑跳转。那么通常会这么写： 12345678- (void)handleJumpType:(ClJumpType)jumpType&#123; if(jumpType == CLJumpTypeAccount)&#123; [self gotoAccountPage]; &#125;else if(jumpType == CLJumpTypeAbout)&#123; [self gotoAboutPage]; &#125; ...&#125; 假如说有十几个枚举，那handleJumpType:方法就会看起来不是很优雅，如果条件有变化的话，不好扩展，而且业务代码牵一发动全身…… 那么骚一点的程序员会怎么写呢？switch/case? 当然不是，我这里推荐使用工厂模式来优雅的处理类似的逻辑。 接下来我们就通过一系列的代码来演示如何通过工厂模式来处理这个问题。 废话不说了上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 类型枚举typedef NS_ENUM(NSUInteger, CLJumpType) &#123; CLJumpTypeAccount = 1, CLJumpTypeAbout = 2, ...&#125;// 点击事件基类@interface CLJumpEvent : NSObject- (instancetype)initWithType:(CLJumpType)jumpType;- (void)jumpEvent;@end@interface CLJumpTypeEvent()@property (nonatmoic, assign) CLJumpType jumpType;@end@implementation CLJumpTypeEvent- (instancetype)initWithType:(CLJumpType)jumpType &#123; if ([self = super init])&#123; self.jumpType = jumpType; &#125; return self;&#125;- (void)jumpEvent &#123; NSLog(@"点击事件处理");&#125;@end// 跳转到我的账户@interface CLJumpTypeAccount : CLJumpTypeEvent@end@implementation CLJumpTypeEvent// 重写基类的jumpEvent方法- (void)jumpEvent &#123; NSLog(@"跳转到我的账户页面...");&#125;@end// 跳转工厂类@interface CLJumpFactory : NSObject + (CLJumpEvent)getJumpEvent:(CLJumpType)jumpType;@end@implementation CLJumpFactory+ (NSDictionary)jumpEvents &#123; return @&#123; @(CLJumpTypeAccount):[[CLJumpTypeEvent alloc]initWithType:CLJumpTypeAccount], @(CLJumpTypeAbout):[[CLJumpTypeEvent alloc]initWithType:CLJumpTypeAbout], ... &#125;&#125;+ (CLJumpEvent)getJumpEvent:(CLJumpType)jumpType&#123; return [[self jumpEvents] objectForKey:@(jumpType)];&#125;@end 到这里，我们的工厂定义完了，那么接下来改造一下上面的handleJumpType：方法: 1234- (void)handleJumpType:(ClJumpType)jumpType&#123; CLJumpTypeEvent *jumpEvent = [CLJumpFactory getJumpEvent:jumpType]; [jumpEvent jumpEvent];&#125; OK，改造完的样子，是不是很优雅？而且如果需要扩展的话，handleJumpType:方法完全不用修改。 通过这个例子是不是觉得利用工厂模式来处理类似的问题十分的合适呢，其实设计模式在实际的开发中还是很有用的，只要我们仔细的去揣摩代码，你会发现它总有一些模式在里面。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles工具进阶篇]]></title>
    <url>%2F2019%2F04%2F25%2FCharles%E5%B7%A5%E5%85%B7%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[我们都知道Charles是一款好用的抓包工具，其实它的功能是非常强大的，下面我们就一起看一下Charles这个工具的一些其他常用功能。 使用Charles进行网络环境模拟在开发中，我们要经常考虑各种边界问题，对于网络开发，告诉网络、弱网络、上行和下行带宽差异等都是我们要进行适配的场景，Charles就可以很好的模拟这些环境。接下来我们就一下看一下如何模拟： 在Charles菜单栏的Proxy菜单中选择 Throttle(节流阀) Settings 菜单项，这个可以用来进行网络字节流的设置，就是我们说的网络环境模拟，如图(1): 图(1) 在弹出的新窗口中，我们就可以进行网络设置了，如图(2)： 图(2) 勾选Enable Throttling选项则表示开启网络节流功能，可以看到，在图(2)的窗口中还有一个Only for selected hosts 选项，开启这个选项后，我们可以配置一些主机地址，从而只会针对这些主机地址的请求进行节流控制。 在Throttle preset 中预设了多种网络环境，对每一种预设都配置了一套网络环境参数，我们也可以自定义。 下面来解释一下窗口中的各个参数：Bandwidth 用来配置上行和下行网络的带宽 Utilisation 用来设置上行和下行网络的利用率。 Round-trip latency 用来设置往返的延迟时间。 MTU设置网络最大传输单元 Reliablity 设置网络可靠率。 Stability 设置网络稳定性。 Unstable quality range 设置不稳定范围。 当我们根据自己的需求自定义了一套网络环境参数后，也可以进行保存，填写完成后点击Add Preset按钮即可新增一种自定义预设，Remove Preset用来删除预设。实际上这个预设是一个XML文件，我们可以将其导出给其他人使用。Charles提供了非常人性化的导入/导出功能。 使用Charles添加请求断点]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多版本Cocoapods切换]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%A4%9A%E7%89%88%E6%9C%ACCocoapods%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[背景很多 iOS 项目都是基于特定版本的 CocoaPods，使用其他版本的 CocoaPods 执行 pod install 或 pod update可能出现项目无法编译的问题。由于我们的电脑上很有可能使用了其他的版本，本文主要介绍如何解决这种多版本 CocoaPods 切换的问题。 查看本地装的pod可以通过1gem list --local | grep cocoapods 命令来查看我们电脑上安装了哪些版本的pod,并可以通过1pod --version 来查看当前默认版本。 使用BundlerBundler 是一个 Ruby 项目的管理工具，可以理解成为 Ruby 界的 “CocoaPods”。准确来说，CocoaPods 是借鉴了 Bundler 的思想和模式。由于 CocoaPods 本身也是一个 Ruby 项目，因此我们可以通过 Bundler 来管理我们要使用的 CocoaPods 版本，完整的步骤如下所示: 安装Bundler,打开终端输入以下命令： 1gem install bundler 在终端中进入到项目所在的根目录就是podfile所在的目录。 创建Bundler的配置文件Gemfile,在终端中输入下面的命令即可。 1bundle init 在Gemfile中设置cocoapods的版本。例如： 12source &quot;https://rubygems.org&quot;gem &quot;cocoapods&quot;, &quot;1.5.3&quot; 安装特定版本的pod,如果已经安装则可忽略这一步。执行如下命令： 1bundle install 此时，Gemfile中配置的pod版本就安装到本地了。 使用Bundler控制上一步安装的pod来安装我们所需的pods。除了有bundle exec 这个前缀，其他和我们平时用pod命令一样。若去掉bundle exec 这个前缀，运行的就是默认版本的cocoapods了。1bundle exec pod install 另外，还可以通过其他方式运行指定版本的pod，如：1pod _1.5.3_ install 亲测有效。]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的FPS监控器]]></title>
    <url>%2F2019%2F01%2F27%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84FPS%E7%9B%91%E6%8E%A7%E5%99%A8%2F</url>
    <content type="text"><![CDATA[最近在看有关iOS性能监控方面的知识，了解到如何通过CADisplayLink来实现一个简单的屏幕刷新帧率监控的方法，在Blog里面做一个Mark。 首先我们要了解一下CADisplayLink是个什么玩意儿，官方给出的解释是这样的： 1A timer object that allows your application to synchronize its drawing to the refresh rate of the display. 说白了，就是以屏幕刷新频率将内容绘制到屏幕上的定时器。它可以以屏幕的刷新频率调用指定的selector,而iOS系统中正常的屏幕刷新频率为60Hz(每秒60次)，那我们只要在这个方法里面统计每秒这个方法执行的次数，通过调用次数除以时间间隔(_count/interval)就可以得出当前屏幕的刷新频率了。 接下来贴出核心代码： 12345678910111213141516171819202122232425262728293031323334353637383940// 开始监控FPS的方法- (void)start &#123; if (_displayLink) &#123; _displayLink.paused = NO; &#125;else &#123; _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(triggerFps:)]; // 让当前runloop在 UITrackingRunloopMode 下可以接收到回调 [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; &#125;&#125;// 刷新频率回调方法- (void)triggerFps:(CADisplayLink *)displayLink &#123; // 大约每1/60秒调用一次 就是说每16.7ms 要产生一帧画面。 // 记录第一次调用时的时间戳 if (_lastTimestamp == 0) &#123; _lastTimestamp = displayLink.timestamp; return; &#125; _count++; // 当count=60 时 interval &gt;= 1 才会执行后面的fps值计算 NSTimeInterval interval = displayLink.timestamp - _lastTimestamp; if (interval &lt; 1) &#123; return; &#125; // 计算出fps CGFloat fps = _count / interval; // 记录上一次的时间戳 _lastTimestamp = displayLink.timestamp; // reset _count _count = 0; // 调整fps值 NSInteger intFps = (NSInteger)(fps + 0.5); self.currentFps = intFps; if (self.FPSBlock) &#123; self.FPSBlock(self.currentFps); &#125;&#125; 通过上面的代码就能统计到帧数的变化了，这个FPS指示器也就完成了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何打包一个依赖第三方framework（如支付宝的framework）的静态framework]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AA%E4%BE%9D%E8%B5%96%E7%AC%AC%E4%B8%89%E6%96%B9framework%EF%BC%88%E5%A6%82%E6%94%AF%E4%BB%98%E5%AE%9D%E7%9A%84framework%EF%BC%89%E7%9A%84%E9%9D%99%E6%80%81framework%2F</url>
    <content type="text"><![CDATA[这篇文章我们主要来探讨一下，如何让一个静态framework 依赖其他的静态framework，本文以活体检测的framework为例来一步步说明是如何实现的。 如何打包一个依赖AFNetworking的静态framework 至于如何打包一个静态库的问题，请查看本人上一篇文章： 这篇文章我们基于上一篇文章中的例子继续讲解。 第一步，我们将需要的三方framework 以及 bundle 导入到CLNetStaticFramework里面的Libs文件夹下，注意！导入的时候Add to targets 这一项一定不要勾选，只需要导入即可如图(1)。之所以这样是因为，静态库是相对独立的，不能一个静态库包含另外一个静态库，只能是依赖，这样不会造成重复引用。 图1这里需要说明的是，这里不添加到target自然不会自动生成framework path，所以需要在工程的Framework Search Paths 里面手动配置一下framework 路径如图(2)，如果不配置的话，引用的三方库头文件时会报找不到头文件错误。 图2然后是添加第三方framework需要的系统库，这里活体检测framework需要的有CoreMedia.framework,CoreMotion.framework，在Build Phases -&gt; Link Binary With Libraries 里面依次添加。另外，还需要将工程中的Enable Bitcode 设置为NO, 此时cmd+b编译一下应该可以通过了。 然后新建一个CLLiveDetect类，这里面会写一些关于活体检测的代码，并调起活体检测SDK.写一些测试代码如图(3) 图3接下来把CLLiveDetect.h暴露出来，暴露方法同上一篇文章中的方法，这里不再赘述。到这里我们就可以cmd+b来build我们的framework 了。 第二步，如何使用刚才构建好的framework? 将我们刚才build的framework 导入到ABSDKDemo工程中，重点来了！！同时也需要将活体检测的framework以及bundle 导入到该工程中。并且也要加上编译需要依赖的framework:CoreMedia.framework,CoreMotion.framework，Enable Bitcode 设置为NO, 否则的话不能通过编译。 导入完成以后cmd+b 一下你会发现工程编译成功了，然后我们运行起来看看效果。结果我们还是以Xcode控制台的日志为准（图（4））。 图4到这里，打包一个依赖第三方framework的静态库已经聊完了，欢迎大家勘误。 需要demo的朋友可以到这里去下载： CLNetStaticFramework 静态库源码 静态库测试工程 源码 欢迎star ^.^,欢迎吐槽。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>静态库</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS线程之多读单写和常驻线程]]></title>
    <url>%2F2018%2F09%2F13%2FiOS%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%AF%BB%E5%8D%95%E5%86%99%E5%92%8C%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[熟悉多线程的朋友，应该都遇到过这样的应用场景： 多个线程去读写数据。那么试想一下如果一条线程正在读取数据的时候另外一条线程同时在写数据。这种场景是否会产生问题呢？ 我们期望这样一个线程，可以被我们反复利用，那么这又是如何实现的呢？ 接下来我们一一介绍 如何解决多个线程对同一块资源的读写问题呢？试想一下，当一个线程在读取资源的时候，正好有另外一个线程修改了这个资源，或者多个线程同时修改资源，这两种情况都会导致数据错乱。所以为了避免这种问题的产生我们应该怎么处理呢？ 我们在多线程读写的时候应该有以下原则： 读者、读者并发 读者、写者互斥 写者、写者互斥 满足以上原则，我们就可以很好的结局上述问题。满足以上原则的话，系统给我们提供了很好用的API:dispatch_barrier_async，它可以很好的将我们的读写操作分离，原则上我们允许多个读取线程同时读取数据，假如说有写线程的话，通过上述dispatch_barrier_async就可以将它之前的读操作隔离开来，同样的如果它后面还有读取线程的话也必须等到，写数据线程执行完之后才会执行。 具体的用法呢，就是通过调用dispatch_barrier_async将写任务提交到一个自定义的并发队列concurrent_queue中，而读取操作呢用过调用dispatch_sync将读取操作以同步的方式提交到自定义的并发队列concurrent_queue中。 接下来我们看具体的实现： 我们声明一个类MultiReadSingle Write 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 接口部分@interface MultiReadSingleWrite : NSObject- (id)objectForKey:(NSString *)key;- (void)setObject:(id)object forKey:(NSString *)key;@end// 实现部分@interface MultiReadSingleWrite ()&#123; // 定义一个并发队列 dispatch_queue_t concurrent_queue; // 定义一个供线程读写的数据容器 NSMutableDictionary *containerDict;&#125;@end@implementation MultiReadSingleWrite- (instancetype)init &#123; if (self = [super init]) &#123; // 定义一个访问容器 containerDict = [[NSMutableDictionary alloc]initWithCapacity:0]; // 创件一个并发队列 concurrent_queue = dispatch_queue_create("read_write_queue", DISPATCH_QUEUE_CONCURRENT); &#125; return self;&#125;// 读取数据- (id)objectForKey:(NSString *)key &#123; __block id value = nil; // 同步读取数据 dispatch_sync(concurrent_queue, ^&#123; value = [containerDict objectForKey:key]; &#125;); return value;&#125;// 写数据- (void)setObject:(id)object forKey:(NSString *)key &#123; // 异步栅栏调用设置数据 dispatch_barrier_async(concurrent_queue, ^&#123; [containerDict setObject:object forKey:key]; &#125;);&#125;@end 没错，就是这么简单，相信你看了我的介绍，对多读单写应该很清楚了。接下来我们来介绍上述第二个问题。 如何创建一个可以反复使用的线程呢？反复使用的线程说白了就是我们通常所说的 常驻线程。那么改如何创建呢？需要满足一下三点： 为当前线程开启一个RunLoop 向该RunLoop中添加一个Port/Sources等维持RunLoop的事件循环 启动该RunLoop 我们看代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142// 接口部分@interface AliveForeverThread : NSObject+ (NSThread *)threadForDispatch;@end // 实现部分static NSThread *thred = nil;static BOOL runAlways = YES;@implementation AliveForeverThread+ (NSThread *)threadForDispatch &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; thred = [[NSThread alloc]initWithTarget:self selector:@selector(runRequest) object:nil]; [thred setName:@"charles_alive_thread"]; [thred start]; &#125;); return thred;&#125;+ (void)runRequest &#123; // 创建一个Source CFRunLoopSourceContext context = &#123;0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL&#125;; CFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &amp;context); // 创建RunLoop CFRunLoopAddSource(CFRunLoopGetCurrent(), source,kCFRunLoopDefaultMode); // 开始运行 while (runAlways) &#123; @autoreleasepool &#123; // 使当前RunLoop运行在DefaultMode下。 CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, true); &#125; &#125; // 某一时机，runAlways = NO 时，可以保证跳出RunLoop,线程退出。 CFRunLoopRemoveSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode); CFRelease(source);&#125;@end 到这里，我们上述的两个问题就介绍完了，欢迎勘误！]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block底层实现之逆向思维]]></title>
    <url>%2F2018%2F08%2F21%2FBlock%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[前段时间心血来潮，研究了一下block底层实现，在网上看了好多文章，基本都是通过clang 将代码转换为C++代码去分析Blcok的实现。今天我们反过来思考，用C去实现一个OC Block的效果。 Block的实现本质上是一些结构体，函数指针，函数，的综合运用。 话不多说，直奔主题： Block的实现，首先需要声明一个结构，这个结构是我们实现Block的基础，也是关键1234567891011struct __block_impl &#123;void *isa; int Flags;int Reserved;void *FuncPtr;&#125;; 说明一下： 1.isa 保存的是Block的类型 2.Flags 当block发生copy时，会用到 3.FuncPtr 指针，指向block内的函数实现（后面函数指针调用的函数） 这个结构体，是所有类型的Block都会有的一部分。 然后我们看第二个结构体1234567static struct __simpleblk_block_desc_0 &#123;size_t reserved;size_t Block_size;&#125; __simpleblk_block_desc_0_DATA = &#123;0,sizeof(struct __simpleblk_block_impl_0)&#125;; 说明一下： 1.reserved 保留字段默认是0 2.Block_size 用来保存block所占内存大小。 这个结构体用来描述block的大小等信息，simpleblk_block_desc_0_DATA是simpleblk_block_desc_0的一个结构体实例。 我们再看第三个结构体，也是Block实现最重要的结构，声明如下：12345678910111213141516171819struct __simpleblk_block_impl_0 &#123;struct __block_impl impl;struct __simpleblk_block_desc_0 *Desc;__simpleblk_block_impl_0(void *fp,struct __simpleblk_block_desc_0 *desc,int flags = 0)&#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;; 说明一下： 从这个结构中可以看到，该结构体含有 block_impl 结构的变量 和 simpleblk_block_desc_0 结构的变量，以及结构体构造函数simpleblk_block_impl_0，结构体构造函数用来初始化变量block_impl和__simpleblk_block_desc_0。 到这里，我们实现最简单的Block所需要的结构就声明完了，但是要达到OC Block 那种效果，仅有结构体 肯定是不够的。截下来我们来看一个关键的函数，你没猜错就是一个很简单的C函数：12345static void __simpleblk_block_func_0(struct __simpleblk_block_impl_0 *__cself) &#123;printf(&quot;this is charles&apos;s simple block!!&quot;);&#125; 这个函数其实就是我们的Block块里面的操作。后面调用之后就会很清楚。 到这里我们就可以写一个C函数来达到一个Block的效果： int simpleblk(){ //声明一个结构体变量1__simpleblk_block_impl_0 __simpleblk_impl0 = __simpleblk_block_impl_0((void *)__simpleblk_block_func_0,&amp;__simpleblk_block_desc_0_DATA); //声明一个函数指针变量block，并且将上面的结构体变量的地址付给block指针1void(*block)(void) = (void(*)())&amp;__simpleblk_impl0; 1234/*下面这句代码 实际上调用的是 __simpleblk_block_func_0（）函数就是函数指针调用函数。*/ 12345((void (*)(struct __block_impl *))((struct __block_impl *)block)-&gt;FuncPtr)((struct __block_impl *)block);return 1;&#125; 其实，上面写了这么多，换成OC代码其实就是在一个函数里面，声明了一个Block变量并且调用它。12345678910111213int simpleblk() &#123;void (^block)(void) = ^()&#123;printf(&quot;this is charles&apos;s block!!&quot;);&#125;;block();return 1;&#125; 到这里我们用C语言实现OC的 Block效果基本就写完了，不知道各位看官是否看明白了呢。。（PS:欢迎大家勘误，共同学习！）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探Category实现原理]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%88%9D%E6%8E%A2Category%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Objective-C 分类的实现原理,阅读runtime源码会发现，分类在运行时的结构是这个样子的： 12345678910111213141516struct category_t &#123; const char *name; // 分类名称 classref_t cls; // 分类所属的宿主类 struct method_list_t *instanceMethods; // 实例方法列表 struct method_list_t *classMethods; // 类方法列表 struct protocol_list_t *protocols; // 协议列表 struct property_list_t *instanceProperties; // 属性列表 method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta) &#123; if (isMeta) return nil; // classProperties; else return instanceProperties; &#125;&#125;; name代表的是分类的名称；cls是分类所属的宿主类；classMethods是实例方法列表；classMethods类方法列表；protocols是协议列表；instanceProperties是属性列表。从中可以发现，可以给分类添加实例方法、类方法、协议、以及属性。 接下来看一下分类在运行时的加载调用栈： 1 _objc_init 2 map_3_images 3 map_images_nolock 4 _read_images 5 remethodizeClass 事实上，分类在运行时加载的入口是从remethodizeClass的方法开始的。该方法的功能是：附加外部的分类到已经存在的类里面；修改方法列表、协议列表、属性列表，更新方法缓存以及其子类。 我们先来看一下这个方法的内部实现，然后一步步的探讨系统是如何给宿主类添加分类的。 123456789101112131415161718192021static void remethodizeClass(Class cls)&#123; category_list *cats; bool isMeta; runtimeLock.assertWriting(); isMeta = cls-&gt;isMetaClass(); // Re-methodizing: check for more categories // 获取cls中未完成整合的所有分类 if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123; if (PrintConnecting) &#123; _objc_inform("CLASS: attaching categories to class '%s' %s", cls-&gt;nameForLogging(), isMeta ? "(meta)" : ""); &#125; attachCategories(cls, cats, true /*flush caches*/); free(cats); &#125;&#125; 方法中的isMeta变量是用来判断我们的分类中是添加的类方法，还是实例方法； if语句中的unattachedCategoriesForClass方法就是用来获取cls中没有被附加的分类列表。 分支里面的attachCategories方法就是用来附加分类的方法列表、属性列表、协议列表到宿主类中的核心方法。 接着看attachCategories方法的内部实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); bool isMeta = cls-&gt;isMetaClass(); // fixme rearrange to remove these intermediate allocations /* 二维数组 [[method_t,menthod_t,...],[method_t],[method_t,method_t],...] */ method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; // 方法个数 int propcount = 0; // 属性个数 int protocount = 0; // 协议个数 int i = cats-&gt;count; // 宿主类分类的总数 bool fromBundle = NO; while (i--) &#123; // 这里是倒序遍历，最先访问最后编译的分类 // 获取一个分类 auto&amp; entry = cats-&gt;list[i]; // 获取该分类的方法列表 method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; // 最后编译的分类最先添加到分类数组中 mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; // 属性列表添加规则 同方法列表添加规则 property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta); if (proplist) &#123; proplists[propcount++] = proplist; &#125; protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; // 获取宿主类当中的rw 数据，其中包含宿主类的方法列表信息 auto rw = cls-&gt;data(); // 主要是针对 分类中有关于内存管理相关方法情况下的 一些特殊处理 prepareMethodLists(cls, mlists, mcount, NO, fromBundle); /* rw 代表类 methods 代表类的方法列表 attachLists 方法的含义是 将mcount个元素的mlists 拼接到rw的methods上 */ rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; isMeta变量的含义同上文，依然是判断添加的方法是实例方法还是类方法。这里我们只讨论为分类添加实例方法的情况，mlists、proplists、protolists这三个都是二维数组，分别代表方法列表、属性列表、协议列表。我这里主要分析关于方法添加的逻辑。method_list_t结构存储的是method_t结构这里它代表一个方法，关于这两个的具体内容大家可以去runtime源码里面找答案。 接下来是代表方法数量的mcount变量，属性数量的propcount变量，协议数量的protocount变量；i指的是宿主类分类的总数。 接下来可以看到是一个倒序的while循环，倒序的含义就是最先访问最后编译的分类，因为cats中的分类是按照编译顺序添加的。 这就抛出来一个问题：如果一个类有两个分类，这两个分类有一个同名方法，那么这两个方法哪个会生效？ 答案就是取决于两个方法所属的分类的编译顺序，就是说看两个分类哪一个最后被加入到cats中。 经过一系列的处理之后呢，就会执行method.attachLists方法来将分类的方法列表添加到宿主类中。 接下来看一下method.attachLists这个方法的内部实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* addedLists 传递过来的二维数组 [[method_t,method_t,...], [method_t], [method_t,method_t,method_t],...] ------------------------ ----------- --------------------------------- 分类A中的方法列表 B C addedCount = 3 */ void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists // 列表中原有元素总数 uint32_t oldCount = array()-&gt;count; // 拼接之后的元素总数 uint32_t newCount = oldCount + addedCount; // 根据拼接之后的总数重新分配空间 setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); // 重新设置元素总数 array()-&gt;count = newCount; /* 内存移动 [[],[],[],[原有的第一个元素],[原有的第二个元素]] */ memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); /* 内存拷贝 [ A ----&gt; [addedLists中的第一个元素], B ----&gt; [addedLists中的第二个元素], C ----&gt; [addedLists中的第三个元素], [原有的第一个元素], [原有的第二个元素] ] 这也是分类方法会“覆盖”宿主类的方法的原因 */ memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; &#125; addedLists是经过处理的方法列表。oldCount是原有元素总数。newCount是拼接之后的元素总数，realloc会重新按照拼接后的总数重新分配空间。然后重新设置元素总数。接下来调用memove移动内存，会将原来的元素向后移动，新拼接的元素会插入到原有元素的前面。最后，调用memcpy拷贝内存，拷贝后的内存存储结构如注释中所示。这也就是分类方法会“覆盖“宿主类方法的原因。 到此为止，分类中的方法已经拼接到宿主类中了。]]></content>
      <tags>
        <tag>Objective-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的明白isKindOfClass 和 isMemberOfClass 的区别么？]]></title>
    <url>%2F2018%2F07%2F23%2F%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%98%8E%E7%99%BDisKindOfClass-%E5%92%8C-isMemberOfClass-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前几天看博客发现了一个关于 isKindOfClass 和 isMemberOfClass 的问题，但是感觉分析的不够透彻，所以我在这里试着分析一下，欢迎大家一起讨论。 内容是这样的 （如图1）。 图1上图中的四个Bool 分别是什么？我在这里先爆出答案：上面是个Bool 分别是：1 ，0，0，0；那么问题来了，为毛会是这个结果？要弄明白这个就要搞清楚isKindOfClass 和 isMemberOfClass 的区别，先来看看官方的说法：isKindOfClass：Returns a Boolean value that indicates whether the receiver is an instance of given class or an instance of any class that inherits from that class.isMemberOfClass：Returns a Boolean value that indicates whether the receiver is an instance of a given class.其实就是这个意思：isKindOfClass：判断对象是否为某类或其派生类的实例。isMemberOfClass：判断对象是否为某个特定类的实例。好，那么先来分析res1 为什么是Yes.首先了解一下class 方法的实现 （图2）图2从图2中可以看出[NSObject class]; 返回的其实还是NSObject,到这里你可能会想NSObject isKindOfClass NSObject 所以 res1 = Yes。But,But,But,重要的事情说三遍，事实并非如此，接着我们来看一下isKindOfClass 方法的实现（图3）图3 以及object_getClass 的实现 （图4） 图4通过查阅objc4 源码 就是上面的图3和图4，会发现object_getClass 返回的是传入的对象的isa,由于我们传入的是类对象，所以isa 指向的是一个元类对象，那么object_getClass((id)self);返回的就是self 的元类对象，那么NSObject 类对象的元类对象是谁呢?如果你了解OC的对象模型的话会知道，NSObject的元类对象为 Meta NSObject Class Object（我们暂且这么叫） 。 回到isKindOfClass 的实现代码里，循环会先获取到NSObject的元类对象即tcls，然后跟NSObject类对象(cls)作比较,此时元类对象不等于类对象，继续循环，找到tcls-&gt;superclass,还是得熟悉OC的对象模型，NSObject 元类对象的super 就是NSObject ，没错就是它，此时 tcls 就是 NSObject 类对象，cls 也是NSObject 类对象，所以tcls 等于cls ，此时循环结束，返回Yes。 到这里不知道各位看官是否明白是怎么回事了呢？ 下面附上isMemberOfClass 的源码实现 图5 图5大家可以通过上面isKindOfClass 的分析，以及我提供的源码截图，可以分析一下其他三种res2,res3，res4的结果为什么全是0。 才疏学浅，欢迎大家勘误。多多交流，互相学习！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中的类和元类]]></title>
    <url>%2F2018%2F07%2F23%2FObjective-C%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[你真的知道OC的类（Class）是个什么玩意儿？ 众所周知，所有的对象都是由其对应的类实例化而来，但是类本身其实也是一种对象，surprise？下面我们就来拨开这层迷雾。 类在Objective-C中，我们用到的几乎所有类都是NSObject类的子类，查阅objc源码你会发现 NSObject类定义（如图1）我们这里只给出定义其他方法大家自行查阅。 图1看完这个,那么问题来了：这个Class 类型的 isa 是个什么玩意儿？Class 又是个什么类型？带着这两个疑问我们查阅一下objc.h中Class 的定义（如图2） 图2看完这个是不是又一脸懵逼！Class 被定义为一个指向objc_class 的结构体指针。那么objc_class 又是个什么玩意儿？我们接着看源码runtime.h中定义（如图3） 图3你会发现，我艹，怎么又一个isa! 下面我们来解答这个疑惑。 其实在Objective-C中任何的类定义都是对象。即在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是苹果公司说的类对象(class object),他是一个单例(singleton), 而我们在其他面向对象语言中所谓的对象，叫做实例对象(instance object)。对于实例对象我们不难理解，但类对象(class object)是个什么鬼？我们知道Objective-C是门很动态的语言，因此程序里的所有实例对象(instace object)都是在运行时由Objective-C的运行时库生成的，而这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。 通过上面的讨论，可以得出结论，不管是实例对象，类对象，其结构中都有一个isa。实例对象中的isa 指针指向的是 该实例的类对象，那么同理，类对象的isa 指向的是谁呢？这就是 元类对象（meta class object）。他们之间的关系看起来是这样的（如图4）： 图4&gt;类对象类对象的本质通过前文我们了解到，类对象是编译器生成的“描述类定义的对象”，就是在编译时的类。任何直接或者间接继承NSObject的类，它的实例对象（instance object）中都有一个isa 指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个实例对象(instace object)所属的类的定义的一切：包括变量，方法，遵守的协议等等，这个可以通过（图3）来佐证。因此，类对象能访问所有关于这个类的信息，利用这些信息可以产生一个新的实例，但是类对象不能访问任何实例对象的内容。当你调用一个 “类方法” 例如 [NSObject alloc],你事实上是发送了一个消息给他的类对象。所谓一切皆对象就是这个意思。 那么类对象与实例对象有什么区别呢？尽管类对象保留了一个类实例的原型，但它并不是实例本身。它没有自己的实例变量，也不能执行那些类的实例的方法（只有实例对象才可以执行实例方法）。然而，类的定义能包含那些特意为类对象准备的方法–类方法（ 而不是的实例方法）。类对象从父类那里继承类方法，就像实例从父类那里继承实例方法一样。 类对象是不是就是类名？只有在消息表达式中作为接收者，类名才代表类对象。我理解为调用静态方法的时候。 元类对象元类对象的实质实际上，类对象是元类对象的一个实例。元类描述了 一个类对象，就像类对象描述了普通对象一样。不同的是元类的方法列表是类方法的集合，由类对象的选择器来响应。当向一个类发送消息时，objc_msgSend会通过类对象的isa指针定位到元类，并检查元类的方法列表（包括父类）来决定调用哪个方法。元类代替了类对象描述了类方法，就像类对象代替了实例对象描述了实例化方法一样。 很显然，元类也是对象，也应该是其他类的实例，实际上元类是根元类(root class’s metaclass)的实例,而根元类是其自身的实例，即根元类的isa指针指向自身。 类的super_class指向其父类，而元类的super_class则指向父类的元类。元类的super class链与类的super class链平行，所以类方法的继承与实例方法的继承也是并行的。而根元类(root class’s metaclass)的super_class指向根类(root class)，这样，整个isa指针链就是一个闭环。 记住，当一个消息发送给任何一个对象， 方法的检查 从对象的 isa 指针开始，然后是父类。实例方法在类中定义， 类方法 在元类和根类中定义。（根类的元类就是根类自己）。在一些计算机语言的原理中，一个类和元类层次结构可以更自由的组成，更深元类链和从单一的元类继承的更多的实例化的类。Objective-C 的类方法 是使用元类的根本原因，在其他方面试图在隐藏元类。例如 [NSObject class] 完全相等于 [NSObject self]，所以，在形式上他还是返回的 NSObject-&gt;isa 指向的元类。 Objective-C语言是一组实用的折中方案。下图表示了对象间的isa的关系，以及类的继承关系： 图片来自网络（图5）综上所述，类对象(class object)中包含了类的实例变量，实例方法的定义，而元类对象(metaclass object)中包括了类的类方法(也就是C++中的静态方法)的定义。类对象和元类对象中当然还会包含一些其它的东西，苹果以后也可能添加其它的内容，但对于我们只需要记住：类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。要注意的是，类对象(class object)和元类对象(metaclass object)的定义都是objc_class结构，其不同仅仅是在用途上，比如其中的方法列表在类对象(instance object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中则保存的是类方法(class method)。 写了这么多不知道能够拨开您心中的迷雾呢？欢迎大家勘误，互相学习！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你用 Intellij IDEA 创建一个简单的SpringBoot项目]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-Intellij-IDEA-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SpringBoot%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[新建Project 默认选中 Default 点击下图的Next 按钮 填写Group、Artifact Package 那一栏和Group 保持一致就好，如果是com.jack.springtest的话会导致 WhiteLabel Error Page 异常 选中Web 选项 然后点击Next 按钮 然后点击Finish 按钮 工程结构如下： 在jack package 下新建”controller” package,在controller 下新建TestController.java,并添加如下图中的代码： 此时点击运行按钮 在地址栏输入：http://localhost:8080/hello 会有如下图输出 配置端口号 和 访问路径 再次运行 在浏览器中输入 http://localhost:8081/springboot/hello 会有上面同样的输出。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端装逼利器 zsh]]></title>
    <url>%2F2018%2F07%2F21%2FMac%E7%BB%88%E7%AB%AF%E8%A3%85%E9%80%BC%E5%88%A9%E5%99%A8-zsh%2F</url>
    <content type="text"><![CDATA[我在使用mac终端执行各种命令的时候，始终感觉不是很方便，比如在开发过程中执行git 命令的时候不清楚当前是是什么分支，得反复的git branch 查看；输入文件夹名称时候还要区分大小写，tab 键才能联想。。。为了解决这个问题，我一番google,原来有这么好用的工具 — zsh 下面我们来介绍一下zsh是如何在mac终端上面装逼的。其实zsh 也是一种sheel,但是并不是我们系统默认的 shell ,unix 衍生系统的默认shell 都是 bash. 查看已安装的shell1cat /etc/shells 可以看到总共六种123456/bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh 将默认shell改成zsh1chsh -s /bin/zsh 安装 oh my zsh手动安装：依次执行如下命令12git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 配置zsh打开配置文件1vim ~/.zshrc 设置一些常用命令的别名12345alias zshconfig=&apos;vi ~/.zshrc&apos;alias vimconfig=&apos;vi ~/.vimrc&apos;alias ll=&apos;ls -l&apos;alias vi=&apos;vim&apos;alias xcode=&apos;open -a &quot;Xcode&quot;&apos; 启用命令纠错功能1ENABLE_CORRECTION=&quot;true&quot; 插件123git osxautojump 只需要在.zshvr中启用1plugins=(git osx autojump) 到这里你可以重启一下你的终端看一下效果 再看一下git效果 有没有很惊艳！ shell的颜色配置去github 上面搜索solarized然后clone 到本地，找到对应的主题比如我们用的是Terminal终端(Mac OSX自带),就找到osx-terminal.app-colors-solarized下的三个文件,双击安装即可。 如何切换颜色打开终端的偏好设置按照下图操作即可： ok，写到这里zsh的基本玩法就结束了！欢迎大家勘误！]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X - 重置 MySQL Root 密码]]></title>
    <url>%2F2018%2F07%2F21%2FMac%20OS%20X%20-%20%E9%87%8D%E7%BD%AE%20MySQL%20Root%20%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一：您是否忘记了Mac OS 的MySQL的root密码? 通过以下4步就可重新设置新密码：1. 停止 mysql server. 通常是在 ‘系统偏好设置’ &gt; MySQL &gt; ‘Stop MySQL Server’2. 打开终端，输入：1$ sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables 3. 打开另一个新终端，依次输入:1$ sudo /usr/local/mysql/bin/mysql -u root 1$ UPDATE mysql.user SET authentication_string=PASSWORD('新密码') WHERE User='root'; 1$ FLUSH PRIVILEGES; 1$ \q 4. 重启MySQL.*以上方法针对 MySQL V5.7.9, 旧版的mysql请使用：UPDATE mysql.user SET Password=PASSWORD(‘新密码’) WHERE User=’root’; 二：安装完mysql 之后，登陆以后，不管运行任何命令，总是提示这个：mac mysql error You must reset your password using ALTER USER statement before executing this statement.12345step 1: SET PASSWORD = PASSWORD('your new password');step 2: ALTER USER 'root'@'localhost' PASSWORD EXPIRE NEVER;step 3: flush privileges; 完成以上三步退出再登，使用新设置的密码就行了，以上除了红色的自己修改成新密码外，其他原样输入即可 12345参考1: https://dev.mysql.com/doc/refman/5.6/en/alter-user.html参考2: http://dev.mysql.com/doc/refman/5.7/en/password-expiration-policy.html参考3: http://stackoverflow.com/questions/33467337/reset-mysql-root-password-using-alter-user-statement-after-install-on-mac]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo快速搭建个人博客]]></title>
    <url>%2F2018%2F07%2F21%2Fhexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是高效的静态网站生成框架，它基于Node.js,通过编辑markdown文件来生成对应的html页面。 准备工作首先安装node.js、安装Git、注册一个github账号。 开始搭建博客开启github pages服务在GitHub上面新建一个仓库如：username.github.io 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是username+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://username.github.io的形式。 安装hexo:以上所有都安装完成之后再安装hexo.1sudo npm install hexo-cli -g 所有必须工具已经安装完成,接下来我们就可以生成博客，上传至我们的github 仓库了。 创建本地博客找一个合适的目录执行如下命令：1hexo init CharlesBlog 安装主题这里我选择的是一个比较流行的主题:next执行如下命令安装：12cd CharlesBloggit clone https://github.com/iissnan/hexo-theme-next themes/next 基础配置：打开文件位置CharlesBlog/_config.yml修改几个键值对，下面把几个必须设置的列出来按需求修改，记得保存， 还有注意配置的键值之间一定要有空格。title: CharlesBlog //你博客的名字author: Charles //你的名字language: zh-Hans //语言 中文theme: next //刚刚安装的主题名称deploy:type: gitrepository: git@github.com:icloud-art/icloud-art.github.io.gitbranch: master主题配置：主题配置文件在username.github.io/themes/next/_config.yml中修改，此处不做详细说明。 新建一篇博客进入CharlesBlog目录执行如下命令：1hexo new testblog 之后会在_post目录下面生成一个testblog.md文件，这个文件就是用来生成对应的html页面。 测试testblog执行如下命令：123hexo cleanhexo ghexo s 然后再浏览器中输入https://localhost:4000 就可以看到刚才创建的博文了（没错，就是testblog）。 安装hexo-deployer-git自动部署发布工具执行如下命令：1npm install hexo-deployer-git --save 发布工具安装好之后就可以使用1hexo d 命令来发布你的博文到GitHub.io当然完成的发布流程是这样的：1hexo clean 1hexo g 1hexo d 好，到这里你可以通过github的域名来访问你的博文了。 时间有限，本文只是简单的介绍了的博客创建流程，还有很多很好玩的配置与插件。比如说评论、标签、统计等等。各位看官慢慢的玩起来吧！]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
  </entry>
</search>
