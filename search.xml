<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flutter使用Packages]]></title>
    <url>%2F2020%2F02%2F16%2FFlutter%E4%BD%BF%E7%94%A8Packages%2F</url>
    <content type="text"><![CDATA[使用 Flutter PackagesFlutter 支持使用其他开发者在Flutter和Dart生态系统中共享的包。这可以使你快速的构建一个应用而不必从头开发一切。这篇文章我来介绍一下如何使用已经发布的packages。 查找包使用一个包之前，首先得找到这个包，我们可以访问pub.dev来查找你需要的包。 添加一个包到项目中添加 css_colors 包到一个项目中有如下步骤: 添加依赖: 打开pubspec.yaml文件，在dependencies下面添加css_colors。 安装依赖：使用终端 cd 到你的项目目录下执行flutter pub get命令,或者在pubspec.yaml顶部点击Packegets get。 导入你添加的包：在你的Dart代码中添加一个正确的 import 语句。 如果需要的话，重启或者停止你的应用：因为热重载和热重启只作用于Dart代码，不会作用于平台特定代码。在使用包的时候做一个重启应用可以有效的避免以下错误。 冲突解决试想一下，如果你在一个应用中想使用 some_package 和 another_package两个包，而这两个包都依赖于url_launcher的不同版本。这就会造成包的版本依赖冲突。那么这种情况我们该如何解决呢？最好的方法来避免这个问题就是在指定依赖的时候使用版本范围而不是一个指定的版本。 123dependencies: url_launcher：^0.4.2 # 任意的0.4.x版本，当x&gt;=2时都生效。 image_picker：‘0.1.1’ # 只有0.1.1版本生效。 如果some_package声明了上面的依赖项，而另一个_package声明了一个兼容的url_launcher依赖项，比如’0.4.5’或^0.4.0，那么Pub会自动解决这个问题。平台对Gradle模块和/或CocoaPods的特定依赖也以类似的方式解决。 即使some_package和another_package声明url_launcher的版本不兼容，它们实际上可能以兼容的方式使用url_launcher。在这种情况下，可以通过在应用程序的pubspec.yaml文件中添加依赖项覆盖声明来解决冲突，强制使用特定的版本。 强制使用url_launcher 0.4.3 版本修改如下代码： 12345dependencies: some_package: another_package:dependency_overrides: url_launcher: &apos;0.4.3&apos; 开发新包如果现有的包满足不了你的特定需求，你可以开发一个自定义的包。下篇文章我们会讲述如何开发一个新包和插件。 管理包依赖和版本为了是冲突的风险最低，我们可以在pubspec.yaml中指定一个版本范围。为了确保应用在包更新时不会中断，我们可以使用以下方式来指定包版本范围： 指定最小和最大的版本的范围约束： 12dependencies: url_launcher: &apos;&gt;=0.1.2 &lt;0.2.0&apos; 使用插入符号语法的范围约束： 12dependencies: collection: &apos;^0.1.2&apos; 更新包依赖当你添加完包以后，第一次使用flutter pub get的时候，Flutter 保存了具体的包版本号在pubspec.lock 文件中。这个确保你和你的团队成员在执行flutter pub get 命令时可以得到同样版本的包。 升级一个包的新版本，例如要使用一个包的新特性，执行flutter pub upgrade来获取pubspec.yaml中版本约束中允许的最高可用版本的包。 依赖没有发布的包没有发布到pub.dev的包也可以用。对于私有的插件，或者没有准备好发布的包，可以使用附加的依赖项选项： Path dependency: 一个Flutter 应用可以通过一个文件系统路径依赖一个插件，路径可以是相对的或者绝对的。例如要依赖一个位于应用统计目录的插件plugin1,可以使用如下语法： 123dependencies: plugin1: path: ../plugin1/ Git dependency:你也可以使用一个存储在git版本库中的包，如果包位于repo的根目录，使用如下语法： 1234dependencies: plugin1: git: url: git://github.com/flutter/plugin1.git Git dependency on a package in a folder:Pub假定包在Git存储仓库的根目录中，如果不是的话，使用path参数来指定路径，例如： 12345dependencies: package1: git: url: git://github.com/flutter/packages.git path: packages/package1 最后，可以使用ref 参数将依赖项固定到特定的git提交，分支或者tag。 到这里，关于Flutter包的使用已经介绍完了，为了方便理解呢，我还是附上一个例子：Flutter包的使用。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS和Flutter通信初探]]></title>
    <url>%2F2020%2F02%2F15%2FiOS%E5%92%8CFlutter%E9%80%9A%E4%BF%A1%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[Flutter 使用了一套灵活的系统来调用平台特定的APIs,无论是iOS还是安卓。Flutter支持平台特定API不是依赖于生成代码的方式，而是通过灵活的消息传递。 应用的Flutter部分发送消息到它的宿主（应用的iOS或者Android部分）通过，platform channel. 应用宿主在platform channel上面监听并且接受消息。然后调用任意数量的特定平台的API（通过原生语言），然后发送一个回调给到Flutter 部分。注意 如果您需要使用Java/Kotlin/Objective-C或Swift中的平台api或库，本文将介绍如何使用平台通道机制。但是，通过检查defaultTargetPlatform属性，您还可以在Flutter应用程序中编写特定于平台的Dart代码。平台适配列出了一些特定于平台的适配，这些适配会在框架中自动执行Flutter。平台渠道的架构概述使用平台通道在客户端(UI)和主机(平台)之间传递消息，如下图所示: 消息和响应是异步传递的，以确保用户界面保持响应性。 尽管Flutter是异步地向Dart发送消息，但无论何时调用channel方法，都必须在平台的主线程上调用该方法。 在客户端，MethodChannel (API)允许发送与方法调用对应的消息。在平台端，Android上的MethodChannel (API)和iOS上的FlutterMethodChannel (API)支持接收方法调用和发送结果。这些类允许您用很少的“样板”代码开发平台插件。 平台通道数据类型支持和编解码器 标准平台通道使用标准消息编解码器，该编解码器支持对简单的json类值(如布尔值、数字、字符串、字节缓冲区以及这些值的列表和映射)的高效二进制序列化(有关详细信息，请参阅StandardMessageCodec)。当您发送和接收值时，这些值与消息之间的序列化和反序列化将自动发生。 下表显示了在平台端接收Dart值的方式，反之亦然。 好了，原理介绍完了，下面一起来看一下具体是如何跑起来的。参照官方文档做了一个在iOS平台获取手机电量的例子。这个例子会示范如何调用平台特定的API来检索以及展示当前设备的电量。它将会使用Android BatteryManager API,和iOS device.batteryLevel API,通过一个单独的平台方法，getBatteryLevel()。 创建一个flutter工程使用如下命令创建：1flutter create platform_channel 或者你可以通过设置特定的语言来指定默认的模板：1flutter create -i objc -a java platform_channel 使用你安装的编译器来打开创建好的工程，我使用的是idea,然后在你工程中的main.dart里面添加如下代码： 123456789101112131415161718class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; // 创建client和host通信的通道 static const platform = const MethodChannel(&apos;charles.flutter.dev/battery&apos;); String _batteryLevel = &apos;Unknown battery level.&apos;; // 获取电量方法 Future&lt;void&gt; _getBatteryLevel()async&#123; String batteryLevel; try&#123; final int result = await platform.invokeMethod(&apos;getBatteryLevel&apos;); batteryLevel = &apos;Battery level at $result % .&apos;; &#125;on PlatformException catch(e)&#123; batteryLevel = &quot;Failed to get battery level: &apos;$&#123;e.message&#125;&apos;.&quot;; &#125; setState(() &#123; _batteryLevel = batteryLevel; &#125;); &#125;&#125; 简单解释一下：首先创建了platform 实例，这个就是通信的通道。client 和 host之间通过通道名称进行连接。单个应用中使用的所有通道名称必须是唯一的，给通道名字添加域前缀，例如：charles.flutter.dev/battery。_getBatteryLevel()方法就是异步的获取当前设备电量的方法。这个方法中最核心的一句： 1final int result = await platform.invokeMethod(&apos;getBatteryLevel&apos;); 就是通过通道，去调用host端的getBatteryLevel方法，并且把获取到的值但会到client端。 展示电量的部分就不介绍了。大家可以看下文附的Demo. host端的话，只介绍iOS端了，安卓类似。有兴趣的朋友可以自己看看。从flutter 项目目录下找到 ios/Runner.xcworkspace 双击打开。在Appdelegate 里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#import &lt;Flutter/Flutter.h&gt;#import &quot;GeneratedPluginRegistrant.h&quot;@implementation AppDelegate- (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions &#123; FlutterViewController* controller = (FlutterViewController*)self.window.rootViewController; FlutterMethodChannel* batteryChannel = [FlutterMethodChannel methodChannelWithName:@&quot;samples.flutter.dev/battery&quot; binaryMessenger:controller]; __weak typeof(self) weakSelf = self; [batteryChannel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) &#123; // Note: this method is invoked on the UI thread. if ([@&quot;getBatteryLevel&quot; isEqualToString:call.method]) &#123; int batteryLevel = [weakSelf getBatteryLevel]; if (batteryLevel == -1) &#123; result([FlutterError errorWithCode:@&quot;UNAVAILABLE&quot; message:@&quot;Battery info unavailable&quot; details:nil]); &#125; else &#123; result(@(batteryLevel)); &#125; &#125; else &#123; result(FlutterMethodNotImplemented); &#125; &#125;]; [GeneratedPluginRegistrant registerWithRegistry:self]; return [super application:application didFinishLaunchingWithOptions:launchOptions];&#125;- (int)getBatteryLevel &#123; UIDevice* device = UIDevice.currentDevice; device.batteryMonitoringEnabled = YES; if (device.batteryState == UIDeviceBatteryStateUnknown) &#123; return -1; &#125; else &#123; return (int)(device.batteryLevel * 100); &#125;&#125;@end 解释一下：这段代码也是先创建一个通道 batteryChannel，可以看到这里使用的channel name 和上文中提到的 client 端里面的完全一致。同时设置了消息的发送者。 getBatteryLevel 就是iOS获取电量的方法，不做过多解释，到此为止，你可以运行platform_channel flutter项目来看一下是否可以获取到当前手机的电量。 效果如下： 附：本文的Demo]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Flutter</tag>
        <tag>Objective-C</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS混合Flutter初探]]></title>
    <url>%2F2020%2F02%2F13%2FiOS%E6%B7%B7%E5%90%88Flutter%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[由于最近公司项目里面要用到Flutter，故研究了一番iOS和Flutter是如何在一起工作的。下面我们就一步步的来介绍一下：开发环境在你心爱的Mac上面安装好Flutter 1.12.13+hotfix.8 • channel stable •、Xcode 11.2.1。 提示：Flutter 支持到iOS8以上。 首先要创建一个iOS项目ios_flutter_hybrid这里就不再详细介绍该项目是如何创建的了。然后集成flutter_module到iOS项目中,flutter 可以作为一个framework嵌入到现有的iOS项目中。要将flutter嵌入到现有的iOS工程中，首先要创建一个flutter_module,它的目录位置最好和项目目录是平行的。执行如下命令： 12cd ios_flutter_hybridflutter create -t module flutter_module 出现如下log就说明执行成功了：123456789101112131415161718Creating project flutter_module... flutter_module/test/widget_test.dart (created) flutter_module/flutter_module.iml (created) flutter_module/.gitignore (created) flutter_module/.metadata (created) flutter_module/pubspec.yaml (created) flutter_module/README.md (created) flutter_module/lib/main.dart (created) flutter_module/flutter_module_android.iml (created) flutter_module/.idea/libraries/Flutter_for_Android.xml (created) flutter_module/.idea/libraries/Dart_SDK.xml (created) flutter_module/.idea/modules.xml (created) flutter_module/.idea/workspace.xml (created)Running &quot;flutter pub get&quot; in flutter_module... 2.0sWrote 12 files.All done!Your module code is in flutter_module/lib/main.dart. 嵌入flutter module 到现有工程中有两种方式将Flutter嵌入到项目中1.使用pod install 安装（推荐使用） （配置一下podfile下面会讲解）2.你编译好一个framework，然后手动嵌入到项目中，并且好手动更新编译配置。注意和Flutter 混合的应用不可以在simulator 上面运行Release模式，因为flutter 不支持为Dart代码提前输出x86二进制文件。你可以在模拟器或真机上面运行Release模式。 我选择的是使用pod来嵌入flutter framework. 需要说明的是flutter 模块的目录和应用程序的目录是平行的，否则可能需要调整相对路径。目录结构如下：1234567some/path/├── flutter_module/│ └── .ios/│ └── Flutter/│ └── podhelper.rb└── ios_flutter_hybrid/ └── Podfile 如果新创建的项目没有podfile 就创建一个podfile。然后在podfile里面添加如下代码：123456flutter_application_path = &apos;../flutter_module&apos;load File.join(flutter_application_path, &apos;.ios&apos;, &apos;Flutter&apos;, &apos;podhelper.rb&apos;)target &apos;ios_flutter_hybrid&apos; do install_all_flutter_pods(flutter_application_path)end 对于每一个需要嵌入flutter的podfile 目标，调用 install_all_flutter_pods(flutter_application_path) 方法。接下来只需要执行 pod install 即可。注意当你在pubspec.yaml中修改了flutter plugin的依赖关系，在flutter module目录下运行flutter pub get 命令来更新podhelper.rb脚本读取的插件列表。然后执行pod install 来安装更新。podhelper.rb脚本将你的plugin、Flutter.framework、App.framework嵌入到工程中。此时，你就开打开ios_flutter_hybrid.xcworkspace 来运行混合好的项目了。 添加一个flutter 页面进入到上面的工程中首先要在Appdelegate里面创建一个FlutterEngine如下代码：123456@import UIKit;@import Flutter;@interface AppDelegate : FlutterAppDelegate // More on the FlutterAppDelegate below.@property (nonatomic,strong) FlutterEngine *flutterEngine;@end 实现部分：1234567891011121314#import &quot;AppDelegate.h&quot;#import &lt;FlutterPluginRegistrant/GeneratedPluginRegistrant.h&gt; // Used to connect plugins.@interface AppDelegate ()@end@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. self.flutterEngine = [[FlutterEngine alloc] initWithName:@&quot;my flutter engine&quot;]; // Runs the default Dart entrypoint with a default Flutter route. [self.flutterEngine run]; [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine]; return [super application:application didFinishLaunchingWithOptions:launchOptions];&#125; 接下来我们在ViewController里面写一个点击事件来吊起一个Flutter页面。在ViewController的viewDidLoad方法中添加如下代码：12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; // Make a button to call the showFlutter function when pressed. UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button addTarget:self action:@selector(showFlutter) forControlEvents:UIControlEventTouchUpInside]; [button setTitle:@&quot;Show Flutter!&quot; forState:UIControlStateNormal]; button.backgroundColor = UIColor.blueColor; button.frame = CGRectMake(80.0, 210.0, 160.0, 40.0); [self.view addSubview:button];&#125; 同时实现一个showFlutter方法: 1234567- (void)showFlutter &#123; FlutterEngine *flutterEngine = ((AppDelegate *)UIApplication.sharedApplication.delegate).flutterEngine; FlutterViewController *flutterViewController = [[FlutterViewController alloc] initWithEngine:flutterEngine nibName:nil bundle:nil]; [self presentViewController:flutterViewController animated:YES completion:nil];&#125; 此时运行一下工程查看效果。不出意外的话你会成功的调起来一个Flutter 页面。 本文Demo代码 下篇文章我们一起来探讨flutter 和 原生iOS代码之间是如何通信的。 欢迎勘误！]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Flutter</tag>
        <tag>Objective-C</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底解决pod install龟速问题]]></title>
    <url>%2F2020%2F02%2F08%2F%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3pod-install%E9%BE%9F%E9%80%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近由于疫情严重，我司果断安排在家办公，在配置开发环境的时候我遇到了让我非常头疼的问题，那就是 pod install 执行时慢的要死。忍不了啊，搜索了一番之后找到了有效的方法，在此做一个Mark。下面我们就来看看是如何提高pod install 的安装速度的。 其实，pod 真正慢的原因不在于你执行的pod 命令而是github上面的代码库访问速度真的慢，翻墙也不行啊。那么真正的t解决办法是提高git 命令的速速。 我们开发者一般都会用代理工具，这里我用的是Shadowsocks代理，我的默认端口号是1086，如下图： 拿到上图中的端口号之后，我们执行一个命令：1git config --global http.https://github.com.proxy socks5://127.0.0.1:1086 这个命令中我设置了只是github上的代码库才走代理。当然我们也可以给git 设置全局代理：1git config --global http.proxy socks5://127.0.0.1:1086 但是第一个命令才是我们需要的。 执行完之后可以对比一下安装的速度：配置命令之前的速度： 配置命令之后的速速： 从图中可以看到，速度提高了许多倍啊！！ 最后提示一下，如果想去掉上面我们配置命令可以采用如下方法： 12去掉全局git代理git config --global --unset http.proxy 12去掉github代理git config --global --unset http.https://github.com.proxy]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles工具进阶篇]]></title>
    <url>%2F2020%2F01%2F31%2FCharles%E5%B7%A5%E5%85%B7%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[我们都知道Charles是一款好用的抓包工具，其实它的功能是非常强大的，下面我们就一起看一下Charles这个工具的一些其他常用功能。 使用Charles进行网络环境模拟在开发中，我们要经常考虑各种边界问题，对于网络开发，告诉网络、弱网络、上行和下行带宽差异等都是我们要进行适配的场景，Charles就可以很好的模拟这些环境。接下来我们就一下看一下如何模拟： 在Charles菜单栏的Proxy菜单中选择 Throttle(节流阀) Settings 菜单项，这个可以用来进行网络字节流的设置，就是我们说的网络环境模拟，如图(1): 图(1) 在弹出的新窗口中，我们就可以进行网络设置了，如图(2)： 图(2) 勾选Enable Throttling选项则表示开启网络节流功能，可以看到，在图(2)的窗口中还有一个Only for selected hosts 选项，开启这个选项后，我们可以配置一些主机地址，从而只会针对这些主机地址的请求进行节流控制。 在Throttle preset 中预设了多种网络环境，对每一种预设都配置了一套网络环境参数，我们也可以自定义。 下面来解释一下窗口中的各个参数：Bandwidth 用来配置上行和下行网络的带宽 Utilisation 用来设置上行和下行网络的利用率。 Round-trip latency 用来设置往返的延迟时间。 MTU设置网络最大传输单元 Reliablity 设置网络可靠率。 Stability 设置网络稳定性。 Unstable quality range 设置不稳定范围。 当我们根据自己的需求自定义了一套网络环境参数后，也可以进行保存，填写完成后点击Add Preset按钮即可新增一种自定义预设，Remove Preset用来删除预设。实际上这个预设是一个XML文件，我们可以将其导出给其他人使用。Charles提供了非常人性化的导入/导出功能。 使用Charles添加请求断点]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多版本Cocoapods切换]]></title>
    <url>%2F2020%2F01%2F31%2F%E5%A4%9A%E7%89%88%E6%9C%ACCocoapods%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[背景很多 iOS 项目都是基于特定版本的 CocoaPods，使用其他版本的 CocoaPods 执行 pod install 或 pod update可能出现项目无法编译的问题。由于我们的电脑上很有可能使用了其他的版本，本文主要介绍如何解决这种多版本 CocoaPods 切换的问题。 查看本地装的pod可以通过1gem list --local | grep cocoapods 命令来查看我们电脑上安装了哪些版本的pod,并可以通过1pod --version 来查看当前默认版本。 使用BundlerBundler 是一个 Ruby 项目的管理工具，可以理解成为 Ruby 界的 “CocoaPods”。准确来说，CocoaPods 是借鉴了 Bundler 的思想和模式。由于 CocoaPods 本身也是一个 Ruby 项目，因此我们可以通过 Bundler 来管理我们要使用的 CocoaPods 版本，完整的步骤如下所示: 安装Bundler,打开终端输入以下命令： 1gem install bundler 在终端中进入到项目所在的根目录就是podfile所在的目录。 创建Bundler的配置文件Gemfile,在终端中输入下面的命令即可。 1bundle init 在Gemfile中设置cocoapods的版本。例如： 12source &quot;https://rubygems.org&quot;gem &quot;cocoapods&quot;, &quot;1.5.3&quot; 安装特定版本的pod,如果已经安装则可忽略这一步。执行如下命令： 1bundle install 此时，Gemfile中配置的pod版本就安装到本地了。 使用Bundler控制上一步安装的pod来安装我们所需的pods。除了有bundle exec 这个前缀，其他和我们平时用pod命令一样。若去掉bundle exec 这个前缀，运行的就是默认版本的cocoapods了。1bundle exec pod install 另外，还可以通过其他方式运行指定版本的pod，如：1pod _1.5.3_ install 亲测有效。]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的FPS监控器]]></title>
    <url>%2F2020%2F01%2F27%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84FPS%E7%9B%91%E6%8E%A7%E5%99%A8%2F</url>
    <content type="text"><![CDATA[最近在看有关iOS性能监控方面的知识，了解到如何通过CADisplayLink来实现一个简单的屏幕刷新帧率监控的方法，在Blog里面做一个Mark。 首先我们要了解一下CADisplayLink是个什么玩意儿，官方给出的解释是这样的： 1A timer object that allows your application to synchronize its drawing to the refresh rate of the display. 说白了，就是以屏幕刷新频率将内容绘制到屏幕上的定时器。它可以以屏幕的刷新频率调用指定的selector,而iOS系统中正常的屏幕刷新频率为60Hz(每秒60次)，那我们只要在这个方法里面统计每秒这个方法执行的次数，通过调用次数除以时间间隔(_count/interval)就可以得出当前屏幕的刷新频率了。 接下来贴出核心代码： 12345678910111213141516171819202122232425262728293031323334353637383940// 开始监控FPS的方法- (void)start &#123; if (_displayLink) &#123; _displayLink.paused = NO; &#125;else &#123; _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(triggerFps:)]; // 让当前runloop在 UITrackingRunloopMode 下可以接收到回调 [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; &#125;&#125;// 刷新频率回调方法- (void)triggerFps:(CADisplayLink *)displayLink &#123; // 大约每1/60秒调用一次 就是说每16.7ms 要产生一帧画面。 // 记录第一次调用时的时间戳 if (_lastTimestamp == 0) &#123; _lastTimestamp = displayLink.timestamp; return; &#125; _count++; // 当count=60 时 interval &gt;= 1 才会执行后面的fps值计算 NSTimeInterval interval = displayLink.timestamp - _lastTimestamp; if (interval &lt; 1) &#123; return; &#125; // 计算出fps CGFloat fps = _count / interval; // 记录上一次的时间戳 _lastTimestamp = displayLink.timestamp; // reset _count _count = 0; // 调整fps值 NSInteger intFps = (NSInteger)(fps + 0.5); self.currentFps = intFps; if (self.FPSBlock) &#123; self.FPSBlock(self.currentFps); &#125;&#125; 通过上面的代码就能统计到帧数的变化了，这个FPS指示器也就完成了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage (5.0.6) 图片缓存读写原理]]></title>
    <url>%2F2019%2F08%2F04%2FSDWebImage%20(5.0.6)%20%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[SDWebImage (5.0.6)图片加载奇淫巧技 这篇文章介绍了SDWebImage加载图片的流程是怎样的，本文我们一起讨论一下，SDWebImage框架的缓存机制是怎么样的。我们先来看加载过程中，SDWebImage是如何从缓存中读取我们所需的图片的，我们先找到读取缓存的入口：12// Start the entry to load image from cache [self callCacheProcessForOperation:operation url:url options:options context:context progress:progressBlock completed:completedBlock]; 这个方法就是开始从缓存中读取，方法内部实现如下：123456789101112131415161718192021222324252627// Query cache process- (void)callCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operationurl:(nonnull NSURL *)urloptions:(SDWebImageOptions)optionscontext:(nullable SDWebImageContext *)contextprogress:(nullable SDImageLoaderProgressBlock)progressBlockcompleted:(nullable SDInternalCompletionBlock)completedBlock &#123; // Check whether we should query cache BOOL shouldQueryCache = (options &amp; SDWebImageFromLoaderOnly) == 0; if (shouldQueryCache) &#123; id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter]; NSString *key = [self cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter]; @weakify(operation); operation.cacheOperation = [self.imageCache queryImageForKey:key options:options context:context completion:^(UIImage * _Nullable cachedImage, NSData * _Nullable cachedData, SDImageCacheType cacheType) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; [self safelyRemoveOperationFromRunning:operation]; return; &#125; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock]; &#125;]; &#125; else &#123; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:nil cachedData:nil cacheType:SDImageCacheTypeNone progress:progressBlock completed:completedBlock]; &#125;&#125; 从上面的源码可以看出，首先会判断一下是否需要从缓存中读取，如果不需要就直接去下载了。如果需要的话，就会使用self.imageCache实例去查询缓存，核心代码：123456789[self.imageCache queryImageForKey:key options:options context:context completion:^(UIImage * _Nullable cachedImage, NSData * _Nullable cachedData, SDImageCacheType cacheType) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; [self safelyRemoveOperationFromRunning:operation]; return; &#125; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock];&#125;]; 我们可以看到，查询结果回调之后，又调用了下载方法，这时因为缓存查询的结果也在下载方法里面处理了。我们接着看查询缓存的方法：queryImageForKey: 看下它的内部实现:1234567891011- (id&lt;SDWebImageOperation&gt;)queryImageForKey:(NSString *)key options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context completion:(nullable SDImageCacheQueryCompletionBlock)completionBlock &#123; SDImageCacheOptions cacheOptions = 0; if (options &amp; SDWebImageQueryMemoryData) cacheOptions |= SDImageCacheQueryMemoryData; if (options &amp; SDWebImageQueryMemoryDataSync) cacheOptions |= SDImageCacheQueryMemoryDataSync; if (options &amp; SDWebImageQueryDiskDataSync) cacheOptions |= SDImageCacheQueryDiskDataSync; if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages; if (options &amp; SDWebImageAvoidDecodeImage) cacheOptions |= SDImageCacheAvoidDecodeImage; if (options &amp; SDWebImageDecodeFirstFrameOnly) cacheOptions |= SDImageCacheDecodeFirstFrameOnly; if (options &amp; SDWebImagePreloadAllFrames) cacheOptions |= SDImageCachePreloadAllFrames; return [self queryCacheOperationForKey:key options:cacheOptions context:context done:completionBlock];&#125; 这个方法里面做了一堆跟缓存相关的条件判断，然后调用了queryCacheOperationForKey:这个方法，正式进入缓存查询。我们接着看这个方法的源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options context:(nullable SDWebImageContext *)context done:(nullable SDImageCacheQueryCompletionBlock)doneBlock &#123; if (!key) &#123; if (doneBlock) &#123; doneBlock(nil, nil, SDImageCacheTypeNone); &#125; return nil; &#125; id&lt;SDImageTransformer&gt; transformer = context[SDWebImageContextImageTransformer]; if (transformer) &#123; // grab the transformed disk image if transformer provided NSString *transformerKey = [transformer transformerKey]; key = SDTransformedKeyForKey(key, transformerKey); &#125; // First check the in-memory cache... UIImage *image = [self imageFromMemoryCacheForKey:key]; if ((options &amp; SDImageCacheDecodeFirstFrameOnly) &amp;&amp; image.sd_isAnimated) &#123; #if SD_MAC image = [[NSImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:kCGImagePropertyOrientationUp]; #else image = [[UIImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:image.imageOrientation]; #endif &#125; BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryMemoryData)); if (shouldQueryMemoryOnly) &#123; if (doneBlock) &#123; doneBlock(image, nil, SDImageCacheTypeMemory); &#125; return nil; &#125; // Second check the disk cache... NSOperation *operation = [NSOperation new]; // Check whether we need to synchronously query disk // 1. in-memory cache hit &amp; memoryDataSync // 2. in-memory cache miss &amp; diskDataSync BOOL shouldQueryDiskSync = ((image &amp;&amp; options &amp; SDImageCacheQueryMemoryDataSync) || (!image &amp;&amp; options &amp; SDImageCacheQueryDiskDataSync)); void(^queryDiskBlock)(void) = ^&#123; if (operation.isCancelled) &#123; // do not call the completion if cancelled return; &#125; @autoreleasepool &#123; NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage; SDImageCacheType cacheType = SDImageCacheTypeNone; if (image) &#123; // the image is from in-memory cache, but need image data diskImage = image; cacheType = SDImageCacheTypeMemory; &#125; else if (diskData) &#123; cacheType = SDImageCacheTypeDisk; // decode image data only if in-memory cache missed diskImage = [self diskImageForKey:key data:diskData options:options context:context]; if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = diskImage.sd_memoryCost; [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; &#125; if (doneBlock) &#123; if (shouldQueryDiskSync) &#123; doneBlock(diskImage, diskData, cacheType); &#125; else &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, cacheType); &#125;); &#125; &#125; &#125; &#125;; // Query in ioQueue to keep IO-safe if (shouldQueryDiskSync) &#123; dispatch_sync(self.ioQueue, queryDiskBlock); &#125; else &#123; dispatch_async(self.ioQueue, queryDiskBlock); &#125; return operation;&#125; 接下来我们解析一下这个方法：首先做了参数合法性判断，不满足条件直接返回空。紧接着就是从内存缓存中查询我们需要的图片：12// First check the in-memory cache...UIImage *image = [self imageFromMemoryCacheForKey:key]; 这个方法比较简单，就是直接从memCache中按照key来读取： [self.memCache objectForKey:key];接下来判断图片是否是动图，做相应的处理。然后，判断是否是只需在内存中查找，如果是的话直接返回刚才查到的图片，并结束方法调用。如果不是的话，就去硬盘中查找。1NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; 我们先把这个流程看完再来看究竟是如何从磁盘中读取Data的。接下来通过一系列条件得出是否需要同步查询缓存：12BOOL shouldQueryDiskSync = ((image &amp;&amp; options &amp; SDImageCacheQueryMemoryDataSync) ||(!image &amp;&amp; options &amp; SDImageCacheQueryDiskDataSync)); 然后生命一个磁盘查询的block: queryDiskBlock开始查询。接下来判断是否从内存中读取到了图片，如果有的话，不做其他处理，最后回调的时候把diskData一起回调出去就可以了。如果没有从内存中读取到图片，则就要看diskData是否为空，如果不为空，就对diskData进行解码处理，得到我们需要的diskImage。12// decode image data only if in-memory cache misseddiskImage = [self diskImageForKey:key data:diskData options:options context:context]; 然后把得到的diskImage放到内存缓存中一份。1234if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = diskImage.sd_memoryCost; [self.memCache setObject:diskImage forKey:key cost:cost];&#125; 到这里，从内存以及磁盘中读取缓存的流程完毕，接下来就是把我们读取出来的图片数据返回给调用方了。123456789if (doneBlock) &#123; if (shouldQueryDiskSync) &#123; doneBlock(diskImage, diskData, cacheType); &#125; else &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, cacheType); &#125;); &#125;&#125; 最后就是根据是否需要同步查询来调用queryDiskBlock了。这就是图片缓存查询的流程。接下来，我们回头看一下磁盘缓存查询究竟是如何实现的。1NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; 我们看一下这个方法的内部实现：1234567891011121314151617181920- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123; if (!key) &#123; return nil; &#125; NSData *data = [self.diskCache dataForKey:key]; if (data) &#123; return data; &#125; // Addtional cache path for custom pre-load cache if (self.additionalCachePathBlock) &#123; NSString *filePath = self.additionalCachePathBlock(key); if (filePath) &#123; data = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil]; &#125; &#125; return data;&#125; 首先是key参数判断，其次从diskCache中通过key来读取，如果磁盘缓存，内存中已经读取过的话，直接返回。否则的话，就会通过key得出磁盘缓存的路径，然后读取出来，返回给调用方。 接下来，我们一起看一下，从Server端下载完图片后，SDWebImage是如何处理的他两级（内存缓存、磁盘缓存）缓存的。同样的我们先找到保存缓存的入口方法：1[self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock]; 这个方法的调用时机，是在从网络下载完图片的回调中。这个方法的内部实现中有一句很重要的代码，就是我们存储缓存的代码：1[self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key cacheType:storeCacheType completion:nil]; 接下来我们来看一下，这个方法的内部实现：1234567891011121314151617181920212223242526- (void)storeImage:(UIImage *)image imageData:(NSData *)imageData forKey:(nullable NSString *)key cacheType:(SDImageCacheType)cacheType completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;switch (cacheType) &#123; case SDImageCacheTypeNone: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:NO toDisk:NO completion:completionBlock]; &#125; break; case SDImageCacheTypeMemory: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:YES toDisk:NO completion:completionBlock]; &#125; break; case SDImageCacheTypeDisk: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:NO toDisk:YES completion:completionBlock]; &#125; break; case SDImageCacheTypeAll: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:YES toDisk:YES completion:completionBlock]; &#125; break; default: &#123; if (completionBlock) &#123; completionBlock(); &#125; &#125; break; &#125;&#125; 内部实现其实比较简单，就是根据缓存类型做相应的存储。这一句才是重点：1[self storeImage:image imageData:imageData forKey:key toMemory:YES toDisk:YES completion:completionBlock]; 我们接着往下面看：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (void)storeImage:(nullable UIImage *)imageimageData:(nullable NSData *)imageDataforKey:(nullable NSString *)keytoMemory:(BOOL)toMemorytoDisk:(BOOL)toDiskcompletion:(nullable SDWebImageNoParamsBlock)completionBlock &#123; if (!image || !key) &#123; if (completionBlock) &#123; completionBlock(); &#125; return; &#125; // if memory cache is enabled if (toMemory &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = image.sd_memoryCost; [self.memCache setObject:image forKey:key cost:cost]; &#125; if (toDisk) &#123; dispatch_async(self.ioQueue, ^&#123; @autoreleasepool &#123; NSData *data = imageData; if (!data &amp;&amp; image) &#123; // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format SDImageFormat format; if ([SDImageCoderHelper CGImageContainsAlpha:image.CGImage]) &#123; format = SDImageFormatPNG; &#125; else &#123; format = SDImageFormatJPEG; &#125; data = [[SDImageCodersManager sharedManager] encodedDataWithImage:image format:format options:nil]; &#125; [self _storeImageDataToDisk:data forKey:key]; &#125; if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; &#125;); &#125; else &#123; if (completionBlock) &#123; completionBlock(); &#125; &#125;&#125; 接着我们分心一下存储缓存的最关键的方法，没错，就是上面的这段代码。首先，对参数进行合法性判断，如果不合法，直接返回。否则继续向下执行:第一步：判断是否允许内存缓存，如果允许就把下载好的图片存储在内存中一份。第二步：判断是否允许存储到磁盘，如果允许就进入磁盘存储逻辑：这里的存储任务是提交到了一个异步的串行队列中。任务的具体处理逻辑是：如果imageData 不存在，但是image 有值，则对image进行归档，得到一份data,这也是我们要写入到磁盘的data。最后，调用_storeImageDataToDisk:方法，将二进制图片数据写入到磁盘。第三步：将结果回调出去。 我们看一下_storeImageDataToDisk:方法的内部实现：12345678// Make sure to call form io queue by caller- (void)_storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123; if (!imageData || !key) &#123; return; &#125; [self.diskCache setData:imageData forKey:key];&#125; 比较简单，就是通过diskCache 实例来写缓存。接着我们进入diskCache类里面看下是如何写入的。我们看下SDDiskCache里面的setData: forKey:方法实现：1234567891011121314151617181920- (void)setData:(NSData *)data forKey:(NSString *)key &#123; NSParameterAssert(data); NSParameterAssert(key); if (![self.fileManager fileExistsAtPath:self.diskCachePath]) &#123; [self.fileManager createDirectoryAtPath:self.diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL]; &#125; // get cache Path for image key NSString *cachePathForKey = [self cachePathForKey:key]; // transform to NSUrl NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey]; [data writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil]; // disable iCloud backup if (self.config.shouldDisableiCloud) &#123; // ignore iCloud backup resource value error [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil]; &#125;&#125; 其实这个也很简单，就是简单的文件写入。 到这里，SDWebImage缓存的读写机制就介绍完了，欢迎大家勘误，SDWebImage这个库比较强大，里面还有很多细节，文中都没有提到，这里只是做了主流程的介绍，读者要是想深入的理解，还得是去阅读源码，建议的阅读的时候，和本文一起读，有助于理解源码。下一篇文章，会介绍SDWebImage是如何对图片进行编码解码的，欢迎大家阅读。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>图片缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage (5.0.6) 图片加载奇淫巧技]]></title>
    <url>%2F2019%2F07%2F29%2FSDWebImage%20(5.0.6)%20%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80%2F</url>
    <content type="text"><![CDATA[最近在研究图片缓存框架，所以SDWebImage一定是我研究的不二选择，下面就简单讲述一下SDWebImage是如何加载图片的，以及加载过程中涉及到的一些骚操作。 这里先强调一点SDWebImage加载图片过程中的两个骚操作：a. 如何避免同一时间多个请求，请求同一张图片下载多次问题。b. 如何解决TableViewCell 复用时导致的图片展示错乱问题。下文中会对这两个问题给出答案，好了不扯淡了，进入正题。 当我们使用SDWebImage加载图片时需要调用如下方法：123- (void)sd_setImageWithURL:(nullable NSURL *)url &#123; [self sd_setImageWithURL:url placeholderImage:nil options:0 progress:nil completed:nil];&#125; 之后进行一系列的传递会传递到最深层的方法：1234567891011121314- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock &#123; [self sd_internalSetImageWithURL:url placeholderImage:placeholder options:options context:context setImageBlock:nil progress:progressBlock completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, cacheType, imageURL); &#125; &#125;];&#125; 可以看到，这个方法里面调用了UIView+Webcache分类里面的一个方法：12345678- (void)sd_internalSetImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context setImageBlock:(nullable SDSetImageBlock)setImageBlock progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; ...... &#125; 这个方法就是我们加载图片的正式入口方法。下面我们看一下这个方法里面都主要做了什么。第一步，根据validOperationKey 取消掉正在执行的操作operation如下调用：123456NSString *validOperationKey = context[SDWebImageContextSetImageOperationKey];if (!validOperationKey) &#123; validOperationKey = NSStringFromClass([self class]);&#125;self.sd_latestOperationKey = validOperationKey;[self sd_cancelImageLoadOperationWithKey:validOperationKey]; sd_cancelImageLoadOperationWithKey: 方法的内部实现会查询到已经存在的同名任务，并且会取消掉这个任务，并在当前view的operationDictionary 容器中移除掉。源码如下：12345678910111213141516171819- (void)sd_cancelImageLoadOperationWithKey:(nullable NSString *)key &#123;if (key) &#123; // Cancel in progress downloader from queue SDOperationsDictionary *operationDictionary = [self sd_operationDictionary]; id&lt;SDWebImageOperation&gt; operation; @synchronized (self) &#123; operation = [operationDictionary objectForKey:key]; &#125; if (operation) &#123; if ([operation conformsToProtocol:@protocol(SDWebImageOperation)]) &#123; [operation cancel]; &#125; @synchronized (self) &#123; [operationDictionary removeObjectForKey:key]; &#125; &#125; &#125;&#125; 这里需要说明一下：[self sd_operationDictionary]这个调用，这个方法的实现是给当前View通过关联对象的技术关联了一个NSMapTable对象，用来存储请求链接接对应的请求操作类型如NSMapTable&lt;NSString *, id&gt;。源码如下：1234567891011- (SDOperationsDictionary *)sd_operationDictionary &#123; @synchronized(self) &#123; SDOperationsDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey); if (operations) &#123; return operations; &#125; operations = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC); return operations; &#125;&#125; 绕了这么大一圈，你可能会问，为什么一上来要调用sd_cancelImageLoadOperationWithKey:这个方法？通过上面的源码分析SDWebImage这样设计是为了解决TableViewCell复用时，如果被复用的Cell的ImageView请求的图片没有回调时展示图片错乱的问题。原理就是如果被复用的Cell的ImageView之前请求的图片还没有回调，而此时需要请求新的图片，那么就取消掉之前的请求operation,并从operationDictionary中移除掉。然后去加载需要加载的新图片。如果说，之前的图片请求在这之后回调回来的话，会判断之前请求的operation是否存在，以及operation的isCancel属性，如果不存在或者isCancel=Yes的话，就不会回调到UI界面。也就是如下代码逻辑：12345678@weakify(operation);operation.loaderOperation = [self.imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data &#125; 说了这么多，相信应该清楚为什么要调用sd_cancelImageLoadOperationWithKey:方法了，我们接着回到sd_internalSetImageWithURL:方法中，cancel之后就会清掉当前imageView上次下载的图片：12345if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123; [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:SDImageCacheTypeNone imageURL:url]; &#125;);&#125; 这里可以解释，复用的时候，已经展示过图片的imageView为什么在被复用的时候没有展示之前存在的图片而是展示placeholer或者不展示的原因。接下来，就是判断我们传入的url是否合法，以及设置UIImageView的加载指示器，还有加载进度block，此处不做详细说明了。我们着重看加载图片的方法：123id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options context:context progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; ......&#125; 这里当前view利用前面生成的manager 去加载我们需要的图片，并把获取的结果回调给了上一级调用方。从上面的代码可以看到，获取图片的同时返回了一个operation，这个operation就是标识获取当前url图片的一个操作。之后会把这个operation放在当前view的operationDictionary中：1[self sd_setImageLoadOperation:operation forKey:validOperationKey]; sd_setImageLoadOperation：内部实现如下:1234567891011- (void)sd_setImageLoadOperation:(nullable id&lt;SDWebImageOperation&gt;)operation forKey:(nullable NSString *)key &#123; if (key) &#123; [self sd_cancelImageLoadOperationWithKey:key]; if (operation) &#123; SDOperationsDictionary *operationDictionary = [self sd_operationDictionary]; @synchronized (self) &#123; [operationDictionary setObject:operation forKey:key]; &#125; &#125; &#125;&#125; 这也是程序一开始时，能够取消掉同名operation的原因。就是同一个view发送一个图片请求就会记录在operationDictionary中来标识有请求正在执行。我们接着看loadImageWithURL:方法内部实现：首先，判断url是否合法，然后生成一个请求图片的operation，这个和我们刚才讲到的operation在内存中是同一个，因为是从该方法中返回出去的。其次，将这个operation添加到正在运行的操作容器中：123SD_LOCK(self.runningOperationsLock);[self.runningOperations addObject:operation];SD_UNLOCK(self.runningOperationsLock); 之后进入重点，那就是开始从缓存中读取图片：12// Start the entry to load image from cache[self callCacheProcessForOperation:operation url:url options:options context:context progress:progressBlock completed:completedBlock]; 同样的，将我们刚才讲到的operation传入到这个方法中。我们看一下这个方法中做了什么：123456789101112131415161718192021222324252627// Query cache process- (void)callCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation url:(nonnull NSURL *)url options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; // Check whether we should query cache BOOL shouldQueryCache = (options &amp; SDWebImageFromLoaderOnly) == 0; if (shouldQueryCache) &#123; id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter]; NSString *key = [self cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter]; @weakify(operation); operation.cacheOperation = [self.imageCache queryImageForKey:key options:options context:context completion:^(UIImage * _Nullable cachedImage, NSData * _Nullable cachedData, SDImageCacheType cacheType) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; [self safelyRemoveOperationFromRunning:operation]; return; &#125; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock]; &#125;]; &#125; else &#123; // Continue download process [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:nil cachedData:nil cacheType:SDImageCacheTypeNone progress:progressBlock completed:completedBlock]; &#125;&#125; 从上面的源码可以看出，首先判断是否需要从缓存中读取图片，如果需要，就处理url,处理后得到我们读取缓存的key。然后，开始从缓存中读取图片，回调之后判断当前operation是否还存在，以及operation是否被取消，如果取消的话就从runningOperations中移除当前operation并返回，什么也不做。否则，调用下载处理程序：callDownloadProcessForOperation：并把我们读取出来的缓存数据传入该方法。接下来我们看看这个方法的内部实现：首先判断是否需要下载图片，如果不需要就判断缓存数据如果缓存有值就直接返回给调用方，如果需要就先看一下之前读取的缓存数据是否有值，如果有值，就直接返回给调用方。如果没有的话，就使用imageLoader下载图片：1234567891011121314151617181920212223242526272829303132333435363738// `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle@weakify(operation);operation.loaderOperation = [self.imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data &#125; else if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached &amp;&amp; [error.domain isEqualToString:SDWebImageErrorDomain] &amp;&amp; error.code == SDWebImageErrorCacheNotModified) &#123; // Image refresh hit the NSURLCache cache, do not call the completion block &#125; else if (error) &#123; [self callCompletionBlockForOperation:operation completion:completedBlock error:error url:url]; BOOL shouldBlockFailedURL = [self shouldBlockFailedURLWithURL:url error:error]; if (shouldBlockFailedURL) &#123; SD_LOCK(self.failedURLsLock); [self.failedURLs addObject:url]; SD_UNLOCK(self.failedURLsLock); &#125; &#125; else &#123; if ((options &amp; SDWebImageRetryFailed)) &#123; SD_LOCK(self.failedURLsLock); [self.failedURLs removeObject:url]; SD_UNLOCK(self.failedURLsLock); &#125; [self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock]; &#125; if (finished) &#123; [self safelyRemoveOperationFromRunning:operation]; &#125;&#125;]; 从上面的源码中可以看出请求图片的回调回来后：1.如果operation不存在或者被取消，什么也不处理2.如果有error则直接回调错误信息，并把当前url加入到filedURLs中。3.如果一切正常，则把错误请求从filedURLs中移除，并把下载好的图片数据传递到缓存处理程序。4.最后，如果finished==YES，则把当前operation从runningOperations中移除。 接下来我们看一下这个方法的内部实现：首先处理一些下载器选项，然后调用下载图片方法：1return [self downloadImageWithURL:url options:downloaderOptions context:context progress:progressBlock completed:completedBlock]; 接着看上面这个方法的内部实现：首先判断url是否合法，如果合法，从下载器的URLOperations属性中读取该url对应的operation，如果operation不存在，或者已经取消或者已经完成，则根据url重新生成一个operation,同时记录该operation到URLOperations中，并把该operation添加到下载队列中去：1234self.URLOperations[url] = operation;// Add operation to operation queue only after all configuration done according to Apple&apos;s doc.// `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.[self.downloadQueue addOperation:operation]; 如果存在operation，但是operation没有正在执行，则根据条件调整operation的请求优先级。如果有正在执行的operation，不创建新的请求operation，而是给当前operation添加回调对象progressBlock 和 completedBlock。 1id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; 看下这个方法的内部实现：12345678910- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlockcompleted:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123; SDCallbacksDictionary *callbacks = [NSMutableDictionary new]; if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy]; if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy]; SD_LOCK(self.callbacksLock); [self.callbackBlocks addObject:callbacks]; SD_UNLOCK(self.callbacksLock); return callbacks;&#125; 从中可以看出一个ImageDownloaderOperation可以有多个回调block。那么问题来了，SDWebImage为什么会这么设计呢？答案是为了解决在同一时间，多个请求同时下载一张图片的时候，对该图片请求只下载一次。也就是请求只发送一次，而请求有结果的时候根据存储的多个返回block 依次返回给调用方。这方法是不是很机智。这一点也可从请求结果的代码中得到验证：1234567891011- (void)callCompletionBlocksWithImage:(nullable UIImage *)imageimageData:(nullable NSData *)imageData error:(nullable NSError *)error finished:(BOOL)finished &#123; NSArray&lt;id&gt; *completionBlocks = [self callbacksForKey:kCompletedCallbackKey]; dispatch_main_async_safe(^&#123; for (SDWebImageDownloaderCompletedBlock completedBlock in completionBlocks) &#123; completedBlock(image, imageData, error, finished); &#125; &#125;);&#125; 从上面的代码中可以看到，方法内部是遍历了所有需要完成回调的completedBlock,然后回调出去。 到这里，SDWebImage加载图片的主要流程就已经基本讲完，本文中着重讲述了下载流程，并没有对缓存部分做详细说明，后面会抽时间完善。欢迎勘误。PS:建议在阅读本文时和源码一起阅读。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>图片缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何打包一个依赖第三方framework（如支付宝的framework）的静态framework]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AA%E4%BE%9D%E8%B5%96%E7%AC%AC%E4%B8%89%E6%96%B9framework%EF%BC%88%E5%A6%82%E6%94%AF%E4%BB%98%E5%AE%9D%E7%9A%84framework%EF%BC%89%E7%9A%84%E9%9D%99%E6%80%81framework%2F</url>
    <content type="text"><![CDATA[这篇文章我们主要来探讨一下，如何让一个静态framework 依赖其他的静态framework，本文以活体检测的framework为例来一步步说明是如何实现的。 如何打包一个依赖AFNetworking的静态framework 至于如何打包一个静态库的问题，请查看本人上一篇文章： 这篇文章我们基于上一篇文章中的例子继续讲解。 第一步，我们将需要的三方framework 以及 bundle 导入到CLNetStaticFramework里面的Libs文件夹下，注意！导入的时候Add to targets 这一项一定不要勾选，只需要导入即可如图(1)。之所以这样是因为，静态库是相对独立的，不能一个静态库包含另外一个静态库，只能是依赖，这样不会造成重复引用。 图1这里需要说明的是，这里不添加到target自然不会自动生成framework path，所以需要在工程的Framework Search Paths 里面手动配置一下framework 路径如图(2)，如果不配置的话，引用的三方库头文件时会报找不到头文件错误。 图2然后是添加第三方framework需要的系统库，这里活体检测framework需要的有CoreMedia.framework,CoreMotion.framework，在Build Phases -&gt; Link Binary With Libraries 里面依次添加。另外，还需要将工程中的Enable Bitcode 设置为NO, 此时cmd+b编译一下应该可以通过了。 然后新建一个CLLiveDetect类，这里面会写一些关于活体检测的代码，并调起活体检测SDK.写一些测试代码如图(3) 图3接下来把CLLiveDetect.h暴露出来，暴露方法同上一篇文章中的方法，这里不再赘述。到这里我们就可以cmd+b来build我们的framework 了。 第二步，如何使用刚才构建好的framework? 将我们刚才build的framework 导入到ABSDKDemo工程中，重点来了！！同时也需要将活体检测的framework以及bundle 导入到该工程中。并且也要加上编译需要依赖的framework:CoreMedia.framework,CoreMotion.framework，Enable Bitcode 设置为NO, 否则的话不能通过编译。 导入完成以后cmd+b 一下你会发现工程编译成功了，然后我们运行起来看看效果。结果我们还是以Xcode控制台的日志为准（图（4））。 图4到这里，打包一个依赖第三方framework的静态库已经聊完了，欢迎大家勘误。 需要demo的朋友可以到这里去下载： CLNetStaticFramework 静态库源码 静态库测试工程 源码 欢迎star ^.^,欢迎吐槽。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>静态库</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端装逼利器 zsh]]></title>
    <url>%2F2018%2F07%2F28%2FMac%E7%BB%88%E7%AB%AF%E8%A3%85%E9%80%BC%E5%88%A9%E5%99%A8-zsh%2F</url>
    <content type="text"><![CDATA[我在使用mac终端执行各种命令的时候，始终感觉不是很方便，比如在开发过程中执行git 命令的时候不清楚当前是是什么分支，得反复的git branch 查看；输入文件夹名称时候还要区分大小写，tab 键才能联想。。。为了解决这个问题，我一番google,原来有这么好用的工具 — zsh 下面我们来介绍一下zsh是如何在mac终端上面装逼的。其实zsh 也是一种sheel,但是并不是我们系统默认的 shell ,unix 衍生系统的默认shell 都是 bash. 查看已安装的shell1cat /etc/shells 可以看到总共六种123456/bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh 将默认shell改成zsh1chsh -s /bin/zsh 安装 oh my zsh手动安装：依次执行如下命令12git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 配置zsh打开配置文件1vim ~/.zshrc 设置一些常用命令的别名12345alias zshconfig=&apos;vi ~/.zshrc&apos;alias vimconfig=&apos;vi ~/.vimrc&apos;alias ll=&apos;ls -l&apos;alias vi=&apos;vim&apos;alias xcode=&apos;open -a &quot;Xcode&quot;&apos; 启用命令纠错功能1ENABLE_CORRECTION=&quot;true&quot; 插件123git osxautojump 只需要在.zshvr中启用1plugins=(git osx autojump) 到这里你可以重启一下你的终端看一下效果 再看一下git效果 有没有很惊艳！ shell的颜色配置去github 上面搜索solarized然后clone 到本地，找到对应的主题比如我们用的是Terminal终端(Mac OSX自带),就找到osx-terminal.app-colors-solarized下的三个文件,双击安装即可。 如何切换颜色打开终端的偏好设置按照下图操作即可： ok，写到这里zsh的基本玩法就结束了！欢迎大家勘误！]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的明白isKindOfClass 和 isMemberOfClass 的区别么？]]></title>
    <url>%2F2018%2F07%2F23%2F%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%98%8E%E7%99%BDisKindOfClass-%E5%92%8C-isMemberOfClass-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前几天看博客发现了一个关于 isKindOfClass 和 isMemberOfClass 的问题，但是感觉分析的不够透彻，所以我在这里试着分析一下，欢迎大家一起讨论。 内容是这样的 （如图1）。 图1上图中的四个Bool 分别是什么？我在这里先爆出答案：上面是个Bool 分别是：1 ，0，0，0；那么问题来了，为毛会是这个结果？要弄明白这个就要搞清楚isKindOfClass 和 isMemberOfClass 的区别，先来看看官方的说法：isKindOfClass：Returns a Boolean value that indicates whether the receiver is an instance of given class or an instance of any class that inherits from that class.isMemberOfClass：Returns a Boolean value that indicates whether the receiver is an instance of a given class.其实就是这个意思：isKindOfClass：判断对象是否为某类或其派生类的实例。isMemberOfClass：判断对象是否为某个特定类的实例。好，那么先来分析res1 为什么是Yes.首先了解一下class 方法的实现 （图2）图2从图2中可以看出[NSObject class]; 返回的其实还是NSObject,到这里你可能会想NSObject isKindOfClass NSObject 所以 res1 = Yes。But,But,But,重要的事情说三遍，事实并非如此，接着我们来看一下isKindOfClass 方法的实现（图3）图3 以及object_getClass 的实现 （图4） 图4通过查阅objc4 源码 就是上面的图3和图4，会发现object_getClass 返回的是传入的对象的isa,由于我们传入的是类对象，所以isa 指向的是一个元类对象，那么object_getClass((id)self);返回的就是self 的元类对象，那么NSObject 类对象的元类对象是谁呢?如果你了解OC的对象模型的话会知道，NSObject的元类对象为 Meta NSObject Class Object（我们暂且这么叫） 。 回到isKindOfClass 的实现代码里，循环会先获取到NSObject的元类对象即tcls，然后跟NSObject类对象(cls)作比较,此时元类对象不等于类对象，继续循环，找到tcls-&gt;superclass,还是得熟悉OC的对象模型，NSObject 元类对象的super 就是NSObject ，没错就是它，此时 tcls 就是 NSObject 类对象，cls 也是NSObject 类对象，所以tcls 等于cls ，此时循环结束，返回Yes。 到这里不知道各位看官是否明白是怎么回事了呢？ 下面附上isMemberOfClass 的源码实现 图5 图5大家可以通过上面isKindOfClass 的分析，以及我提供的源码截图，可以分析一下其他三种res2,res3，res4的结果为什么全是0。 才疏学浅，欢迎大家勘误。多多交流，互相学习！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中的类和元类]]></title>
    <url>%2F2018%2F07%2F23%2FObjective-C%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[你真的知道OC的类（Class）是个什么玩意儿？ 众所周知，所有的对象都是由其对应的类实例化而来，但是类本身其实也是一种对象，surprise？下面我们就来拨开这层迷雾。 类在Objective-C中，我们用到的几乎所有类都是NSObject类的子类，查阅objc源码你会发现 NSObject类定义（如图1）我们这里只给出定义其他方法大家自行查阅。 图1看完这个,那么问题来了：这个Class 类型的 isa 是个什么玩意儿？Class 又是个什么类型？带着这两个疑问我们查阅一下objc.h中Class 的定义（如图2） 图2看完这个是不是又一脸懵逼！Class 被定义为一个指向objc_class 的结构体指针。那么objc_class 又是个什么玩意儿？我们接着看源码runtime.h中定义（如图3） 图3你会发现，我艹，怎么又一个isa! 下面我们来解答这个疑惑。 其实在Objective-C中任何的类定义都是对象。即在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是苹果公司说的类对象(class object),他是一个单例(singleton), 而我们在其他面向对象语言中所谓的对象，叫做实例对象(instance object)。对于实例对象我们不难理解，但类对象(class object)是个什么鬼？我们知道Objective-C是门很动态的语言，因此程序里的所有实例对象(instace object)都是在运行时由Objective-C的运行时库生成的，而这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。 通过上面的讨论，可以得出结论，不管是实例对象，类对象，其结构中都有一个isa。实例对象中的isa 指针指向的是 该实例的类对象，那么同理，类对象的isa 指向的是谁呢？这就是 元类对象（meta class object）。他们之间的关系看起来是这样的（如图4）： 图4&gt;类对象类对象的本质通过前文我们了解到，类对象是编译器生成的“描述类定义的对象”，就是在编译时的类。任何直接或者间接继承NSObject的类，它的实例对象（instance object）中都有一个isa 指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个实例对象(instace object)所属的类的定义的一切：包括变量，方法，遵守的协议等等，这个可以通过（图3）来佐证。因此，类对象能访问所有关于这个类的信息，利用这些信息可以产生一个新的实例，但是类对象不能访问任何实例对象的内容。当你调用一个 “类方法” 例如 [NSObject alloc],你事实上是发送了一个消息给他的类对象。所谓一切皆对象就是这个意思。 那么类对象与实例对象有什么区别呢？尽管类对象保留了一个类实例的原型，但它并不是实例本身。它没有自己的实例变量，也不能执行那些类的实例的方法（只有实例对象才可以执行实例方法）。然而，类的定义能包含那些特意为类对象准备的方法–类方法（ 而不是的实例方法）。类对象从父类那里继承类方法，就像实例从父类那里继承实例方法一样。 类对象是不是就是类名？只有在消息表达式中作为接收者，类名才代表类对象。我理解为调用静态方法的时候。 元类对象元类对象的实质实际上，类对象是元类对象的一个实例。元类描述了 一个类对象，就像类对象描述了普通对象一样。不同的是元类的方法列表是类方法的集合，由类对象的选择器来响应。当向一个类发送消息时，objc_msgSend会通过类对象的isa指针定位到元类，并检查元类的方法列表（包括父类）来决定调用哪个方法。元类代替了类对象描述了类方法，就像类对象代替了实例对象描述了实例化方法一样。 很显然，元类也是对象，也应该是其他类的实例，实际上元类是根元类(root class’s metaclass)的实例,而根元类是其自身的实例，即根元类的isa指针指向自身。 类的super_class指向其父类，而元类的super_class则指向父类的元类。元类的super class链与类的super class链平行，所以类方法的继承与实例方法的继承也是并行的。而根元类(root class’s metaclass)的super_class指向根类(root class)，这样，整个isa指针链就是一个闭环。 记住，当一个消息发送给任何一个对象， 方法的检查 从对象的 isa 指针开始，然后是父类。实例方法在类中定义， 类方法 在元类和根类中定义。（根类的元类就是根类自己）。在一些计算机语言的原理中，一个类和元类层次结构可以更自由的组成，更深元类链和从单一的元类继承的更多的实例化的类。Objective-C 的类方法 是使用元类的根本原因，在其他方面试图在隐藏元类。例如 [NSObject class] 完全相等于 [NSObject self]，所以，在形式上他还是返回的 NSObject-&gt;isa 指向的元类。 Objective-C语言是一组实用的折中方案。下图表示了对象间的isa的关系，以及类的继承关系： 图片来自网络（图5）综上所述，类对象(class object)中包含了类的实例变量，实例方法的定义，而元类对象(metaclass object)中包括了类的类方法(也就是C++中的静态方法)的定义。类对象和元类对象中当然还会包含一些其它的东西，苹果以后也可能添加其它的内容，但对于我们只需要记住：类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。要注意的是，类对象(class object)和元类对象(metaclass object)的定义都是objc_class结构，其不同仅仅是在用途上，比如其中的方法列表在类对象(instance object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中则保存的是类方法(class method)。 写了这么多不知道能够拨开您心中的迷雾呢？欢迎大家勘误，互相学习！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你用 Intellij IDEA 创建一个简单的SpringBoot项目]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-Intellij-IDEA-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SpringBoot%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[新建Project 默认选中 Default 点击下图的Next 按钮 填写Group、Artifact Package 那一栏和Group 保持一致就好，如果是com.jack.springtest的话会导致 WhiteLabel Error Page 异常 选中Web 选项 然后点击Next 按钮 然后点击Finish 按钮 工程结构如下： 在jack package 下新建”controller” package,在controller 下新建TestController.java,并添加如下图中的代码： 此时点击运行按钮 在地址栏输入：http://localhost:8080/hello 会有如下图输出 配置端口号 和 访问路径 再次运行 在浏览器中输入 http://localhost:8081/springboot/hello 会有上面同样的输出。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block底层实现之逆向思维]]></title>
    <url>%2F2018%2F07%2F21%2FBlock%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[前段时间心血来潮，研究了一下block底层实现，在网上看了好多文章，基本都是通过clang 将代码转换为C++代码去分析Blcok的实现。今天我们反过来思考，用C去实现一个OC Block的效果。 Block的实现本质上是一些结构体，函数指针，函数，的综合运用。 话不多说，直奔主题： Block的实现，首先需要声明一个结构，这个结构是我们实现Block的基础，也是关键1234567891011struct __block_impl &#123;void *isa; int Flags;int Reserved;void *FuncPtr;&#125;; 说明一下： 1.isa 保存的是Block的类型 2.Flags 当block发生copy时，会用到 3.FuncPtr 指针，指向block内的函数实现（后面函数指针调用的函数） 这个结构体，是所有类型的Block都会有的一部分。 然后我们看第二个结构体1234567static struct __simpleblk_block_desc_0 &#123;size_t reserved;size_t Block_size;&#125; __simpleblk_block_desc_0_DATA = &#123;0,sizeof(struct __simpleblk_block_impl_0)&#125;; 说明一下： 1.reserved 保留字段默认是0 2.Block_size 用来保存block所占内存大小。 这个结构体用来描述block的大小等信息，simpleblk_block_desc_0_DATA是simpleblk_block_desc_0的一个结构体实例。 我们再看第三个结构体，也是Block实现最重要的结构，声明如下：12345678910111213141516171819struct __simpleblk_block_impl_0 &#123;struct __block_impl impl;struct __simpleblk_block_desc_0 *Desc;__simpleblk_block_impl_0(void *fp,struct __simpleblk_block_desc_0 *desc,int flags = 0)&#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;; 说明一下： 从这个结构中可以看到，该结构体含有 block_impl 结构的变量 和 simpleblk_block_desc_0 结构的变量，以及结构体构造函数simpleblk_block_impl_0，结构体构造函数用来初始化变量block_impl和__simpleblk_block_desc_0。 到这里，我们实现最简单的Block所需要的结构就声明完了，但是要达到OC Block 那种效果，仅有结构体 肯定是不够的。截下来我们来看一个关键的函数，你没猜错就是一个很简单的C函数：12345static void __simpleblk_block_func_0(struct __simpleblk_block_impl_0 *__cself) &#123;printf(&quot;this is charles&apos;s simple block!!&quot;);&#125; 这个函数其实就是我们的Block块里面的操作。后面调用之后就会很清楚。 到这里我们就可以写一个C函数来达到一个Block的效果： int simpleblk(){ //声明一个结构体变量1__simpleblk_block_impl_0 __simpleblk_impl0 = __simpleblk_block_impl_0((void *)__simpleblk_block_func_0,&amp;__simpleblk_block_desc_0_DATA); //声明一个函数指针变量block，并且将上面的结构体变量的地址付给block指针1void(*block)(void) = (void(*)())&amp;__simpleblk_impl0; 1234/*下面这句代码 实际上调用的是 __simpleblk_block_func_0（）函数就是函数指针调用函数。*/ 12345((void (*)(struct __block_impl *))((struct __block_impl *)block)-&gt;FuncPtr)((struct __block_impl *)block);return 1;&#125; 其实，上面写了这么多，换成OC代码其实就是在一个函数里面，声明了一个Block变量并且调用它。12345678910111213int simpleblk() &#123;void (^block)(void) = ^()&#123;printf(&quot;this is charles&apos;s block!!&quot;);&#125;;block();return 1;&#125; 到这里我们用C语言实现OC的 Block效果基本就写完了，不知道各位看官是否看明白了呢。。（PS:欢迎大家勘误，共同学习！）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X - 重置 MySQL Root 密码]]></title>
    <url>%2F2018%2F07%2F21%2FMac%20OS%20X%20-%20%E9%87%8D%E7%BD%AE%20MySQL%20Root%20%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一：您是否忘记了Mac OS 的MySQL的root密码? 通过以下4步就可重新设置新密码：1. 停止 mysql server. 通常是在 ‘系统偏好设置’ &gt; MySQL &gt; ‘Stop MySQL Server’2. 打开终端，输入：1$ sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables 3. 打开另一个新终端，依次输入:1$ sudo /usr/local/mysql/bin/mysql -u root 1$ UPDATE mysql.user SET authentication_string=PASSWORD('新密码') WHERE User='root'; 1$ FLUSH PRIVILEGES; 1$ \q 4. 重启MySQL.*以上方法针对 MySQL V5.7.9, 旧版的mysql请使用：UPDATE mysql.user SET Password=PASSWORD(‘新密码’) WHERE User=’root’; 二：安装完mysql 之后，登陆以后，不管运行任何命令，总是提示这个：mac mysql error You must reset your password using ALTER USER statement before executing this statement.12345step 1: SET PASSWORD = PASSWORD('your new password');step 2: ALTER USER 'root'@'localhost' PASSWORD EXPIRE NEVER;step 3: flush privileges; 完成以上三步退出再登，使用新设置的密码就行了，以上除了红色的自己修改成新密码外，其他原样输入即可 12345参考1: https://dev.mysql.com/doc/refman/5.6/en/alter-user.html参考2: http://dev.mysql.com/doc/refman/5.7/en/password-expiration-policy.html参考3: http://stackoverflow.com/questions/33467337/reset-mysql-root-password-using-alter-user-statement-after-install-on-mac]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo快速搭建个人博客]]></title>
    <url>%2F2018%2F07%2F21%2Fhexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是高效的静态网站生成框架，它基于Node.js,通过编辑markdown文件来生成对应的html页面。 准备工作首先安装node.js、安装Git、注册一个github账号。 开始搭建博客开启github pages服务在GitHub上面新建一个仓库如：username.github.io 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是username+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://username.github.io的形式。 安装hexo:以上所有都安装完成之后再安装hexo.1sudo npm install hexo-cli -g 所有必须工具已经安装完成,接下来我们就可以生成博客，上传至我们的github 仓库了。 创建本地博客找一个合适的目录执行如下命令：1hexo init CharlesBlog 安装主题这里我选择的是一个比较流行的主题:next执行如下命令安装：12cd CharlesBloggit clone https://github.com/iissnan/hexo-theme-next themes/next 基础配置：打开文件位置CharlesBlog/_config.yml修改几个键值对，下面把几个必须设置的列出来按需求修改，记得保存， 还有注意配置的键值之间一定要有空格。title: CharlesBlog //你博客的名字author: Charles //你的名字language: zh-Hans //语言 中文theme: next //刚刚安装的主题名称deploy:type: gitrepository: git@github.com:icloud-art/icloud-art.github.io.gitbranch: master主题配置：主题配置文件在username.github.io/themes/next/_config.yml中修改，此处不做详细说明。 新建一篇博客进入CharlesBlog目录执行如下命令：1hexo new testblog 之后会在_post目录下面生成一个testblog.md文件，这个文件就是用来生成对应的html页面。 测试testblog执行如下命令：123hexo cleanhexo ghexo s 然后再浏览器中输入https://localhost:4000 就可以看到刚才创建的博文了（没错，就是testblog）。 安装hexo-deployer-git自动部署发布工具执行如下命令：1npm install hexo-deployer-git --save 发布工具安装好之后就可以使用1hexo d 命令来发布你的博文到GitHub.io当然完成的发布流程是这样的：1hexo clean 1hexo g 1hexo d 好，到这里你可以通过github的域名来访问你的博文了。 时间有限，本文只是简单的介绍了的博客创建流程，还有很多很好玩的配置与插件。比如说评论、标签、统计等等。各位看官慢慢的玩起来吧！]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
  </entry>
</search>
