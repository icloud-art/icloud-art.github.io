<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何打包一个依赖第三方framework（如支付宝的framework）的静态framework]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AA%E4%BE%9D%E8%B5%96%E7%AC%AC%E4%B8%89%E6%96%B9framework%EF%BC%88%E5%A6%82%E6%94%AF%E4%BB%98%E5%AE%9D%E7%9A%84framework%EF%BC%89%E7%9A%84%E9%9D%99%E6%80%81framework%2F</url>
    <content type="text"><![CDATA[这篇文章我们主要来探讨一下，如何让一个静态framework 依赖其他的静态framework，本文以活体检测的framework为例来一步步说明是如何实现的。 如何打包一个依赖AFNetworking的静态framework 至于如何打包一个静态库的问题，请查看本人上一篇文章： 这篇文章我们基于上一篇文章中的例子继续讲解。 第一步，我们将需要的三方framework 以及 bundle 导入到CLNetStaticFramework里面的Libs文件夹下，注意！导入的时候Add to targets 这一项一定不要勾选，只需要导入即可如图(1)。之所以这样是因为，静态库是相对独立的，不能一个静态库包含另外一个静态库，只能是依赖，这样不会造成重复引用。 图1这里需要说明的是，这里不添加到target自然不会自动生成framework path，所以需要在工程的Framework Search Paths 里面手动配置一下framework 路径如图(2)，如果不配置的话，引用的三方库头文件时会报找不到头文件错误。 图2然后是添加第三方framework需要的系统库，这里活体检测framework需要的有CoreMedia.framework,CoreMotion.framework，在Build Phases -&gt; Link Binary With Libraries 里面依次添加。另外，还需要将工程中的Enable Bitcode 设置为NO, 此时cmd+b编译一下应该可以通过了。 然后新建一个CLLiveDetect类，这里面会写一些关于活体检测的代码，并调起活体检测SDK.写一些测试代码如图(3) 图3接下来把CLLiveDetect.h暴露出来，暴露方法同上一篇文章中的方法，这里不再赘述。到这里我们就可以cmd+b来build我们的framework 了。 第二步，如何使用刚才构建好的framework? 将我们刚才build的framework 导入到ABSDKDemo工程中，重点来了！！同时也需要将活体检测的framework以及bundle 导入到该工程中。并且也要加上编译需要依赖的framework:CoreMedia.framework,CoreMotion.framework，Enable Bitcode 设置为NO, 否则的话不能通过编译。 导入完成以后cmd+b 一下你会发现工程编译成功了，然后我们运行起来看看效果。结果我们还是以Xcode控制台的日志为准（图（4））。 图4到这里，打包一个依赖第三方framework的静态库已经聊完了，欢迎大家勘误。 需要demo的朋友可以到这里去下载： CLNetStaticFramework 静态库源码 静态库测试工程 源码 欢迎star ^.^,欢迎吐槽。]]></content>
      <categories>
        <category>技术人生</category>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>静态库</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端装逼利器 zsh]]></title>
    <url>%2F2018%2F07%2F28%2FMac%E7%BB%88%E7%AB%AF%E8%A3%85%E9%80%BC%E5%88%A9%E5%99%A8-zsh%2F</url>
    <content type="text"><![CDATA[我在使用mac终端执行各种命令的时候，始终感觉不是很方便，比如在开发过程中执行git 命令的时候不清楚当前是是什么分支，得反复的git branch 查看；输入文件夹名称时候还要区分大小写，tab 键才能联想。。。为了解决这个问题，我一番google,原来有这么好用的工具 — zsh 下面我们来介绍一下zsh是如何在mac终端上面装逼的。其实zsh 也是一种sheel,但是并不是我们系统默认的 shell ,unix 衍生系统的默认shell 都是 bash. 查看已安装的shell1cat /etc/shells 可以看到总共六种123456/bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh 将默认shell改成zsh1chsh -s /bin/zsh 安装 oh my zsh手动安装：依次执行如下命令12git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 配置zsh打开配置文件1vim ~/.zshrc 设置一些常用命令的别名12345alias zshconfig=&apos;vi ~/.zshrc&apos;alias vimconfig=&apos;vi ~/.vimrc&apos;alias ll=&apos;ls -l&apos;alias vi=&apos;vim&apos;alias xcode=&apos;open -a &quot;Xcode&quot;&apos; 启用命令纠错功能1ENABLE_CORRECTION=&quot;true&quot; 插件123git osxautojump 只需要在.zshvr中启用1plugins=(git osx autojump) 到这里你可以重启一下你的终端看一下效果 再看一下git效果 有没有很惊艳！ shell的颜色配置去github 上面搜索solarized然后clone 到本地，找到对应的主题比如我们用的是Terminal终端(Mac OSX自带),就找到osx-terminal.app-colors-solarized下的三个文件,双击安装即可。 如何切换颜色打开终端的偏好设置按照下图操作即可： ok，写到这里zsh的基本玩法就结束了！欢迎大家勘误！]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的明白isKindOfClass 和 isMemberOfClass 的区别么？]]></title>
    <url>%2F2018%2F07%2F23%2F%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%98%8E%E7%99%BDisKindOfClass-%E5%92%8C-isMemberOfClass-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前几天看博客发现了一个关于 isKindOfClass 和 isMemberOfClass 的问题，但是感觉分析的不够透彻，所以我在这里试着分析一下，欢迎大家一起讨论。 内容是这样的 （如图1）。 图1上图中的四个Bool 分别是什么？ 我在这里先爆出答案：上面是个Bool 分别是：1 ，0，0，0； 那么问题来了，为毛会是这个结果？ 要弄明白这个就要搞清楚isKindOfClass 和 isMemberOfClass 的区别，先来看看官方的说法： isKindOfClass：Returns a Boolean value that indicates whether the receiver is an instance of given class or an instance of any class that inherits from that class. isMemberOfClass：Returns a Boolean value that indicates whether the receiver is an instance of a given class. 其实就是这个意思： isKindOfClass：判断对象是否为某类或其派生类的实例。 isMemberOfClass：判断对象是否为某个特定类的实例。 好，那么先来分析res1 为什么是Yes. 首先了解一下class 方法的实现 （图2） 图2从图2中可以看出[NSObject class]; 返回的其实还是NSObject,到这里你可能会想 NSObject isKindOfClass NSObject 所以 res1 = Yes。But,But,But,重要的事情说三遍，事实并非如此，接着我们来看一下isKindOfClass 方法的实现（图3） 图3以及object_getClass 的实现 （图4） 图4通过查阅objc4 源码 就是上面的图3和图4，会发现object_getClass 返回的是传入的对象的isa,由于我们传入的是类对象，所以isa 指向的是一个元类对象，那么object_getClass((id)self);返回的就是self 的元类对象，那么NSObject 类对象的元类对象是谁呢?如果你了解OC的对象模型的话会知道，NSObject的元类对象为 Meta NSObject Class Object（我们暂且这么叫） 。 回到isKindOfClass 的实现代码里，循环会先获取到NSObject的元类对象即tcls，然后跟NSObject类对象(cls)作比较,此时元类对象不等于类对象，继续循环，找到tcls-&gt;superclass,还是得熟悉OC的对象模型，NSObject 元类对象的super 就是NSObject ，没错就是它，此时 tcls 就是 NSObject 类对象，cls 也是NSObject 类对象，所以tcls 等于cls ，此时循环结束，返回Yes。 到这里不知道各位看官是否明白是怎么回事了呢？ 下面附上isMemberOfClass 的源码实现 图5 图5大家可以通过上面isKindOfClass 的分析，以及我提供的源码截图，可以分析一下其他三种res2,res3，res4的结果为什么全是0。 才疏学浅，欢迎大家勘误。多多交流，互相学习！]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中的类和元类]]></title>
    <url>%2F2018%2F07%2F23%2FObjective-C%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[你真的知道OC的类（Class）是个什么玩意儿？ 众所周知，所有的对象都是由其对应的类实例化而来，但是类本身其实也是一种对象，surprise？下面我们就来拨开这层迷雾。 类在Objective-C中，我们用到的几乎所有类都是NSObject类的子类，查阅objc源码你会发现 NSObject类定义（如图1）我们这里只给出定义其他方法大家自行查阅。 图1看完这个,那么问题来了：这个Class 类型的 isa 是个什么玩意儿？Class 又是个什么类型？带着这两个疑问我们查阅一下objc.h中Class 的定义（如图2） 图2看完这个是不是又一脸懵逼！Class 被定义为一个指向objc_class 的结构体指针。那么objc_class 又是个什么玩意儿？我们接着看源码runtime.h中定义（如图3） 图3你会发现，我艹，怎么又一个isa! 下面我们来解答这个疑惑。 其实在Objective-C中任何的类定义都是对象。即在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是苹果公司说的类对象(class object),他是一个单例(singleton), 而我们在其他面向对象语言中所谓的对象，叫做实例对象(instance object)。对于实例对象我们不难理解，但类对象(class object)是个什么鬼？我们知道Objective-C是门很动态的语言，因此程序里的所有实例对象(instace object)都是在运行时由Objective-C的运行时库生成的，而这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。 通过上面的讨论，可以得出结论，不管是实例对象，类对象，其结构中都有一个isa。实例对象中的isa 指针指向的是 该实例的类对象，那么同理，类对象的isa 指向的是谁呢？这就是 元类对象（meta class object）。他们之间的关系看起来是这样的（如图4）： 图4&gt;类对象类对象的本质通过前文我们了解到，类对象是编译器生成的“描述类定义的对象”，就是在编译时的类。任何直接或者间接继承NSObject的类，它的实例对象（instance object）中都有一个isa 指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个实例对象(instace object)所属的类的定义的一切：包括变量，方法，遵守的协议等等，这个可以通过（图3）来佐证。因此，类对象能访问所有关于这个类的信息，利用这些信息可以产生一个新的实例，但是类对象不能访问任何实例对象的内容。当你调用一个 “类方法” 例如 [NSObject alloc],你事实上是发送了一个消息给他的类对象。所谓一切皆对象就是这个意思。 那么类对象与实例对象有什么区别呢？尽管类对象保留了一个类实例的原型，但它并不是实例本身。它没有自己的实例变量，也不能执行那些类的实例的方法（只有实例对象才可以执行实例方法）。然而，类的定义能包含那些特意为类对象准备的方法–类方法（ 而不是的实例方法）。类对象从父类那里继承类方法，就像实例从父类那里继承实例方法一样。 类对象是不是就是类名？只有在消息表达式中作为接收者，类名才代表类对象。我理解为调用静态方法的时候。 元类对象元类对象的实质实际上，类对象是元类对象的一个实例。元类描述了 一个类对象，就像类对象描述了普通对象一样。不同的是元类的方法列表是类方法的集合，由类对象的选择器来响应。当向一个类发送消息时，objc_msgSend会通过类对象的isa指针定位到元类，并检查元类的方法列表（包括父类）来决定调用哪个方法。元类代替了类对象描述了类方法，就像类对象代替了实例对象描述了实例化方法一样。 很显然，元类也是对象，也应该是其他类的实例，实际上元类是根元类(root class’s metaclass)的实例,而根元类是其自身的实例，即根元类的isa指针指向自身。 类的super_class指向其父类，而元类的super_class则指向父类的元类。元类的super class链与类的super class链平行，所以类方法的继承与实例方法的继承也是并行的。而根元类(root class’s metaclass)的super_class指向根类(root class)，这样，整个isa指针链就是一个闭环。 记住，当一个消息发送给任何一个对象， 方法的检查 从对象的 isa 指针开始，然后是父类。实例方法在类中定义， 类方法 在元类和根类中定义。（根类的元类就是根类自己）。在一些计算机语言的原理中，一个类和元类层次结构可以更自由的组成，更深元类链和从单一的元类继承的更多的实例化的类。Objective-C 的类方法 是使用元类的根本原因，在其他方面试图在隐藏元类。例如 [NSObject class] 完全相等于 [NSObject self]，所以，在形式上他还是返回的 NSObject-&gt;isa 指向的元类。 Objective-C语言是一组实用的折中方案。下图表示了对象间的isa的关系，以及类的继承关系： 图片来自网络（图5）综上所述，类对象(class object)中包含了类的实例变量，实例方法的定义，而元类对象(metaclass object)中包括了类的类方法(也就是C++中的静态方法)的定义。类对象和元类对象中当然还会包含一些其它的东西，苹果以后也可能添加其它的内容，但对于我们只需要记住：类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。要注意的是，类对象(class object)和元类对象(metaclass object)的定义都是objc_class结构，其不同仅仅是在用途上，比如其中的方法列表在类对象(instance object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中则保存的是类方法(class method)。 写了这么多不知道能够拨开您心中的迷雾呢？欢迎大家勘误，互相学习！]]></content>
      <categories>
        <category>技术人生</category>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你用 Intellij IDEA 创建一个简单的SpringBoot项目]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-Intellij-IDEA-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SpringBoot%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[新建Project 默认选中 Default 点击下图的Next 按钮 填写Group、Artifact Package 那一栏和Group 保持一致就好，如果是com.jack.springtest的话会导致 WhiteLabel Error Page 异常 选中Web 选项 然后点击Next 按钮 然后点击Finish 按钮 工程结构如下： 在jack package 下新建”controller” package,在controller 下新建TestController.java,并添加如下图中的代码： 此时点击运行按钮 在地址栏输入：http://localhost:8080/hello 会有如下图输出 配置端口号 和 访问路径 再次运行 在浏览器中输入 http://localhost:8081/springboot/hello 会有上面同样的输出。]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block底层实现之逆向思维]]></title>
    <url>%2F2018%2F07%2F21%2FBlock%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[前段时间心血来潮，研究了一下block底层实现，在网上看了好多文章，基本都是通过clang 将代码转换为C++代码去分析Blcok的实现。今天我们反过来思考，用C去实现一个OC Block的效果。 Block的实现本质上是一些结构体，函数指针，函数，的综合运用。 话不多说，直奔主题： Block的实现，首先需要声明一个结构，这个结构是我们实现Block的基础，也是关键1234567891011struct __block_impl &#123;void *isa; int Flags;int Reserved;void *FuncPtr;&#125;; 说明一下： 1.isa 保存的是Block的类型 2.Flags 当block发生copy时，会用到 3.FuncPtr 指针，指向block内的函数实现（后面函数指针调用的函数） 这个结构体，是所有类型的Block都会有的一部分。 然后我们看第二个结构体1234567static struct __simpleblk_block_desc_0 &#123;size_t reserved;size_t Block_size;&#125; __simpleblk_block_desc_0_DATA = &#123;0,sizeof(struct __simpleblk_block_impl_0)&#125;; 说明一下： 1.reserved 保留字段默认是0 2.Block_size 用来保存block所占内存大小。 这个结构体用来描述block的大小等信息，simpleblk_block_desc_0_DATA是simpleblk_block_desc_0的一个结构体实例。 我们再看第三个结构体，也是Block实现最重要的结构，声明如下：12345678910111213141516171819struct __simpleblk_block_impl_0 &#123;struct __block_impl impl;struct __simpleblk_block_desc_0 *Desc;__simpleblk_block_impl_0(void *fp,struct __simpleblk_block_desc_0 *desc,int flags = 0)&#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;; 说明一下： 从这个结构中可以看到，该结构体含有 block_impl 结构的变量 和 simpleblk_block_desc_0 结构的变量，以及结构体构造函数simpleblk_block_impl_0，结构体构造函数用来初始化变量block_impl和__simpleblk_block_desc_0。 到这里，我们实现最简单的Block所需要的结构就声明完了，但是要达到OC Block 那种效果，仅有结构体 肯定是不够的。截下来我们来看一个关键的函数，你没猜错就是一个很简单的C函数：12345static void __simpleblk_block_func_0(struct __simpleblk_block_impl_0 *__cself) &#123;printf(&quot;this is charles&apos;s simple block!!&quot;);&#125; 这个函数其实就是我们的Block块里面的操作。后面调用之后就会很清楚。 到这里我们就可以写一个C函数来达到一个Block的效果： int simpleblk(){ //声明一个结构体变量1__simpleblk_block_impl_0 __simpleblk_impl0 = __simpleblk_block_impl_0((void *)__simpleblk_block_func_0,&amp;__simpleblk_block_desc_0_DATA); //声明一个函数指针变量block，并且将上面的结构体变量的地址付给block指针1void(*block)(void) = (void(*)())&amp;__simpleblk_impl0; 1234/*下面这句代码 实际上调用的是 __simpleblk_block_func_0（）函数就是函数指针调用函数。*/ 12345((void (*)(struct __block_impl *))((struct __block_impl *)block)-&gt;FuncPtr)((struct __block_impl *)block);return 1;&#125; 其实，上面写了这么多，换成OC代码其实就是在一个函数里面，声明了一个Block变量并且调用它。12345678910111213int simpleblk() &#123;void (^block)(void) = ^()&#123;printf(&quot;this is charles&apos;s block!!&quot;);&#125;;block();return 1;&#125; 到这里我们用C语言实现OC的 Block效果基本就写完了，不知道各位看官是否看明白了呢。。（PS:欢迎大家勘误，共同学习！）]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X - 重置 MySQL Root 密码]]></title>
    <url>%2F2018%2F07%2F21%2FMac%20OS%20X%20-%20%E9%87%8D%E7%BD%AE%20MySQL%20Root%20%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一：您是否忘记了Mac OS 的MySQL的root密码? 通过以下4步就可重新设置新密码：1. 停止 mysql server. 通常是在 ‘系统偏好设置’ &gt; MySQL &gt; ‘Stop MySQL Server’2. 打开终端，输入：1$ sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables 3. 打开另一个新终端，依次输入:1$ sudo /usr/local/mysql/bin/mysql -u root 1$ UPDATE mysql.user SET authentication_string=PASSWORD('新密码') WHERE User='root'; 1$ FLUSH PRIVILEGES; 1$ \q 4. 重启MySQL.*以上方法针对 MySQL V5.7.9, 旧版的mysql请使用：UPDATE mysql.user SET Password=PASSWORD(‘新密码’) WHERE User=’root’; 二：安装完mysql 之后，登陆以后，不管运行任何命令，总是提示这个：mac mysql error You must reset your password using ALTER USER statement before executing this statement.12345step 1: SET PASSWORD = PASSWORD('your new password');step 2: ALTER USER 'root'@'localhost' PASSWORD EXPIRE NEVER;step 3: flush privileges; 完成以上三步退出再登，使用新设置的密码就行了，以上除了红色的自己修改成新密码外，其他原样输入即可 12345参考1: https://dev.mysql.com/doc/refman/5.6/en/alter-user.html参考2: http://dev.mysql.com/doc/refman/5.7/en/password-expiration-policy.html参考3: http://stackoverflow.com/questions/33467337/reset-mysql-root-password-using-alter-user-statement-after-install-on-mac]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo快速搭建个人博客]]></title>
    <url>%2F2018%2F07%2F21%2Fhexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是高效的静态网站生成框架，它基于Node.js,通过编辑markdown文件来生成对应的html页面。 准备工作首先安装node.js、安装Git、注册一个github账号。 开始搭建博客开启github pages服务在GitHub上面新建一个仓库如：username.github.io 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是username+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://username.github.io的形式。 安装hexo:以上所有都安装完成之后再安装hexo.1sudo npm install hexo-cli -g 所有必须工具已经安装完成,接下来我们就可以生成博客，上传至我们的github 仓库了。 创建本地博客找一个合适的目录执行如下命令：1hexo init CharlesBlog 安装主题这里我选择的是一个比较流行的主题:next执行如下命令安装：12cd CharlesBloggit clone https://github.com/iissnan/hexo-theme-next themes/next 基础配置：打开文件位置CharlesBlog/_config.yml修改几个键值对，下面把几个必须设置的列出来按需求修改，记得保存， 还有注意配置的键值之间一定要有空格。title: CharlesBlog //你博客的名字author: Charles //你的名字language: zh-Hans //语言 中文theme: next //刚刚安装的主题名称deploy:type: gitrepository: git@github.com:icloud-art/icloud-art.github.io.gitbranch: master主题配置：主题配置文件在username.github.io/themes/next/_config.yml中修改，此处不做详细说明。 新建一篇博客进入CharlesBlog目录执行如下命令：1hexo new testblog 之后会在_post目录下面生成一个testblog.md文件，这个文件就是用来生成对应的html页面。 测试testblog执行如下命令：123hexo cleanhexo ghexo s 然后再浏览器中输入https://localhost:4000 就可以看到刚才创建的博文了（没错，就是testblog）。 安装hexo-deployer-git自动部署发布工具执行如下命令：1npm install hexo-deployer-git --save 发布工具安装好之后就可以使用1hexo d 命令来发布你的博文到GitHub.io当然完成的发布流程是这样的：1hexo clean 1hexo g 1hexo d 好，到这里你可以通过github的域名来访问你的博文了。 时间有限，本文只是简单的介绍了的博客创建流程，还有很多很好玩的配置与插件。比如说评论、标签、统计等等。各位看官慢慢的玩起来吧！]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
  </entry>
</search>
